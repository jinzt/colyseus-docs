{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Colyseus\u662fNode.js\u7684\u6743\u5a01\u591a\u4eba\u6e38\u620f\u670d\u52a1\u5668\u3002\u5b83\u4f7f\u60a8\u53ef\u4ee5\u4e13\u6ce8\u4e8e\u81ea\u5df1\u7684\u6e38\u620f\u73a9\u6cd5\uff0c\u800c\u4e0d\u5fc5\u4e3a\u7f51\u7edc\u70e6\u607c\u3002 \u8be5\u6846\u67b6\u7684\u4efb\u52a1\u662f\u6210\u4e3a\u4f7f\u7528JavaScript\u521b\u5efa\u81ea\u5df1\u7684\u591a\u4eba\u6e38\u620f\u7684\u6700\u7b80\u5355\u89e3\u51b3\u65b9\u6848\u3002 Colyseus\u4e3a\u60a8\u63d0\u4f9b\u7684\u5185\u5bb9\uff1a \u00b6 \u57fa\u4e8eWebSocket\u7684\u901a\u4fe1 \u670d\u52a1\u5668\u7aef\u548c\u5ba2\u6237\u7aef\u4e2d\u7684\u7b80\u5355API \u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u4e4b\u95f4\u7684\u81ea\u52a8\u72b6\u6001\u540c\u6b65 \u5bf9\u63a5\u4f1a\u5ba2\u6237\u8fdb\u5165\u6e38\u620f\u73af\u8282 \u5782\u76f4\u6216\u6c34\u5e73\u6269\u5c55 Colyseus\u4e0d\u63d0\u4f9b\u7684\u5185\u5bb9\uff1a \u00b6 \u6e38\u620f\u5f15\u64ce\uff1aColyseus\u4e0e\u60a8\u4f7f\u7528\u7684\u5f15\u64ce\u65e0\u5173\u3002\u9700\u8981\u7269\u7406\u5b66\u5417\uff1f\u6dfb\u52a0\u60a8\u81ea\u5df1\u7684\u903b\u8f91/\u5305\u3002 \u6570\u636e\u5e93\uff1a\u7531\u60a8\u51b3\u5b9a\u662f\u5426\u914d\u7f6e\u548c\u9009\u62e9\u8981\u4f7f\u7528\u7684\u6570\u636e\u5e93\u3002 \u601d\u7ef4 \u00b6 \u6743\u5a01\u7684\u6e38\u620f\u670d\u52a1\u5668\u601d\u7ef4\u65b9\u5f0f\u975e\u5e38\u7b80\u5355\u3002\u670d\u52a1\u5668\u9a8c\u8bc1\u7528\u6237\u7684\u52a8\u4f5c\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u662f\u5f53\u524d\u6e38\u620f\u72b6\u6001\u7684\u865a\u62df\u8868\u793a\u3002 \u670d\u52a1\u5668\u5e94\u5904\u7406\u6e38\u620f\u4e2d\u6d89\u53ca\u7684\u6240\u6709\u6570\u636e\uff0c\u4f8b\u5982\u4f4d\u7f6e\uff0c\u901f\u5ea6\uff0c\u78b0\u649e\u7b49\u3002 \u5236\u4f5c\u591a\u4eba\u6e38\u620f\u901a\u5e38\u5f88\u68d8\u624b\uff0c\u56e0\u4e3a\u60a8\u7684\u6e38\u620f\u73a9\u6cd5\u5fc5\u987b\u8003\u8651\u591a\u4e2a\u5ef6\u8fdf-\u5176\u4ed6\u5ba2\u6237\u7aef\u5c06\u6570\u636e\u53d1\u9001\u5230\u670d\u52a1\u5668\uff0c\u800c\u670d\u52a1\u5668\u5c06\u6570\u636e\u53d1\u9001\u56de\u6240\u6709\u5ba2\u6237\u7aef\u3002\u4f2a\u9020\u5df2\u7ecf\u53d1\u751f\u7684\u4e8b\u60c5\u7684\u827a\u672f\u5b9e\u9645\u4e0a\u662f\u5728\u5f53\u524d\u73a9\u5bb6\u89c2\u770b\u548c\u73a9\u6e38\u620f\u65f6\u53d1\u751f\u7684\u4e8b\u60c5\u3002 \u8fd9\u662f\u5728Colyseus\u4e0a\u7684\u201c\u591a\u4eba\u6e38\u620f\u5faa\u73af\u201d\u7684\u6837\u5b50\uff1a \u5ba2\u6237\u7aef\u5411\u670d\u52a1\u5668\u53d1\u9001\u4e00\u6761\u6d88\u606f\uff0c\u8bf7\u6c42\u66f4\u6539\u5176\u72b6\u6001\u3002 \u8f93\u5165\u5fc5\u987b\u7531\u60a8\u7684\u623f\u95f4\u7ba1\u7406\u5458\u9a8c\u8bc1\u3002 \u623f\u95f4\u72b6\u6001\u5df2\u66f4\u65b0\u3002 \u6240\u6709\u5ba2\u6237\u7aef\u90fd\u4f1a\u6536\u5230\u6e38\u620f\u72b6\u6001\u7684\u6700\u65b0\u7248\u672c\u3002 \u6e38\u620f\u72b6\u6001\u7684\u89c6\u89c9\u8868\u793a\u5df2\u66f4\u65b0\u3002 \u7b80\u56fe \u00b6 room.send({ action: \"left\" }) | +------------+ | +-----------------------------------+ +-----+ Client #1 +-------| | Room handler #1 | | +------------+ | | | | +------------+ | | onMessage (client, data) { | |-----+ Client #2 | --------+ if (data.action === \"left\") { | | +------------+ | // update the room state | | +------------+ | } | |-----+ Client #3 | | } | | +------------+ +-----------------------------------+ | | | patch state broadcast (binary diff) | |----------------------------------------------------+ \u4eba\u4eec\u5bf9Colyseus\u8bf4\u4ec0\u4e48\uff1f? \u00b6 @bmovement \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\" @sagestudios Loved the framework. Exactly what we are looking for in terms of features. \u5916\u90e8\u94fe\u63a5 \u00b6 \ud83d\udcac Chat / Discord \ud83d\udcac \u8bba\u575b \ud83d\udcb0 \u652f\u6301\u9879\u76ee \ud83c\udf10 \u7f51\u7ad9","title":"\u4e3b\u9875"},{"location":"#colyseus","text":"\u57fa\u4e8eWebSocket\u7684\u901a\u4fe1 \u670d\u52a1\u5668\u7aef\u548c\u5ba2\u6237\u7aef\u4e2d\u7684\u7b80\u5355API \u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u4e4b\u95f4\u7684\u81ea\u52a8\u72b6\u6001\u540c\u6b65 \u5bf9\u63a5\u4f1a\u5ba2\u6237\u8fdb\u5165\u6e38\u620f\u73af\u8282 \u5782\u76f4\u6216\u6c34\u5e73\u6269\u5c55","title":"Colyseus\u4e3a\u60a8\u63d0\u4f9b\u7684\u5185\u5bb9\uff1a"},{"location":"#colyseus_1","text":"\u6e38\u620f\u5f15\u64ce\uff1aColyseus\u4e0e\u60a8\u4f7f\u7528\u7684\u5f15\u64ce\u65e0\u5173\u3002\u9700\u8981\u7269\u7406\u5b66\u5417\uff1f\u6dfb\u52a0\u60a8\u81ea\u5df1\u7684\u903b\u8f91/\u5305\u3002 \u6570\u636e\u5e93\uff1a\u7531\u60a8\u51b3\u5b9a\u662f\u5426\u914d\u7f6e\u548c\u9009\u62e9\u8981\u4f7f\u7528\u7684\u6570\u636e\u5e93\u3002","title":"Colyseus\u4e0d\u63d0\u4f9b\u7684\u5185\u5bb9\uff1a"},{"location":"#_1","text":"\u6743\u5a01\u7684\u6e38\u620f\u670d\u52a1\u5668\u601d\u7ef4\u65b9\u5f0f\u975e\u5e38\u7b80\u5355\u3002\u670d\u52a1\u5668\u9a8c\u8bc1\u7528\u6237\u7684\u52a8\u4f5c\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u662f\u5f53\u524d\u6e38\u620f\u72b6\u6001\u7684\u865a\u62df\u8868\u793a\u3002 \u670d\u52a1\u5668\u5e94\u5904\u7406\u6e38\u620f\u4e2d\u6d89\u53ca\u7684\u6240\u6709\u6570\u636e\uff0c\u4f8b\u5982\u4f4d\u7f6e\uff0c\u901f\u5ea6\uff0c\u78b0\u649e\u7b49\u3002 \u5236\u4f5c\u591a\u4eba\u6e38\u620f\u901a\u5e38\u5f88\u68d8\u624b\uff0c\u56e0\u4e3a\u60a8\u7684\u6e38\u620f\u73a9\u6cd5\u5fc5\u987b\u8003\u8651\u591a\u4e2a\u5ef6\u8fdf-\u5176\u4ed6\u5ba2\u6237\u7aef\u5c06\u6570\u636e\u53d1\u9001\u5230\u670d\u52a1\u5668\uff0c\u800c\u670d\u52a1\u5668\u5c06\u6570\u636e\u53d1\u9001\u56de\u6240\u6709\u5ba2\u6237\u7aef\u3002\u4f2a\u9020\u5df2\u7ecf\u53d1\u751f\u7684\u4e8b\u60c5\u7684\u827a\u672f\u5b9e\u9645\u4e0a\u662f\u5728\u5f53\u524d\u73a9\u5bb6\u89c2\u770b\u548c\u73a9\u6e38\u620f\u65f6\u53d1\u751f\u7684\u4e8b\u60c5\u3002 \u8fd9\u662f\u5728Colyseus\u4e0a\u7684\u201c\u591a\u4eba\u6e38\u620f\u5faa\u73af\u201d\u7684\u6837\u5b50\uff1a \u5ba2\u6237\u7aef\u5411\u670d\u52a1\u5668\u53d1\u9001\u4e00\u6761\u6d88\u606f\uff0c\u8bf7\u6c42\u66f4\u6539\u5176\u72b6\u6001\u3002 \u8f93\u5165\u5fc5\u987b\u7531\u60a8\u7684\u623f\u95f4\u7ba1\u7406\u5458\u9a8c\u8bc1\u3002 \u623f\u95f4\u72b6\u6001\u5df2\u66f4\u65b0\u3002 \u6240\u6709\u5ba2\u6237\u7aef\u90fd\u4f1a\u6536\u5230\u6e38\u620f\u72b6\u6001\u7684\u6700\u65b0\u7248\u672c\u3002 \u6e38\u620f\u72b6\u6001\u7684\u89c6\u89c9\u8868\u793a\u5df2\u66f4\u65b0\u3002","title":"\u601d\u7ef4"},{"location":"#_2","text":"room.send({ action: \"left\" }) | +------------+ | +-----------------------------------+ +-----+ Client #1 +-------| | Room handler #1 | | +------------+ | | | | +------------+ | | onMessage (client, data) { | |-----+ Client #2 | --------+ if (data.action === \"left\") { | | +------------+ | // update the room state | | +------------+ | } | |-----+ Client #3 | | } | | +------------+ +-----------------------------------+ | | | patch state broadcast (binary diff) | |----------------------------------------------------+","title":"\u7b80\u56fe"},{"location":"#colyseus_2","text":"@bmovement \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\" @sagestudios Loved the framework. Exactly what we are looking for in terms of features.","title":"\u4eba\u4eec\u5bf9Colyseus\u8bf4\u4ec0\u4e48\uff1f?"},{"location":"#_3","text":"\ud83d\udcac Chat / Discord \ud83d\udcac \u8bba\u575b \ud83d\udcb0 \u652f\u6301\u9879\u76ee \ud83c\udf10 \u7f51\u7ad9","title":"\u5916\u90e8\u94fe\u63a5"},{"location":"authentication/","text":"This section covers the configuration and usage of @colyseus/social . @colyseus/social is an experimental module that provides general-purpose backend services to speed-up your multiplayer game development experience. The API is open for suggestions and improvement. Tip If you're looking to implement your own authentication method, see Server API \u00bb Authentication Installation \u00b6 Download and install MongoDB Install the @colyseus/social module. npm install @colyseus/social npm install express-jwt Import and expose the Express routes provided by @colyseus/social . import express from \"express\" ; import socialRoutes from \"@colyseus/social/express\" const app = express (); app . use ( \"/\" , socialRoutes ); app . listen ( 8080 ); Server-side configuration \u00b6 Environment Variables \u00b6 MONGO_URI : MongoDB connection URI JWT_SECRET : Secure secret string for authentication. FACEBOOK_APP_TOKEN : Facebook App Token ( \"appid|appsecret\" ) Server-side API \u00b6 The @colyseus/social module provides the MongoDB models, and the token validation function available for you to use. import { User , FriendRequest , verifyToken } from \"@colyseus/social\" ; Implementing onAuth to retrieve the current user \u00b6 import { User , verifyToken } from \"@colyseus/social\" ; class MyRoom extends Room { async onAuth ( client , options ) { // verify token authenticity const token = verifyToken ( options . token ); // query the user by its id return await User . findById ( token . _id ); } onJoin ( client , options , user ) { console . log ( user . username , \"has joined the room!\" ); } } Hooks \u00b6 hooks.beforeAuthenticate \u00b6 The beforeAuthenticate hook is triggered before a user logs in or registers. import { hooks } from \"@colyseus/social\" ; hooks . beforeAuthenticate (( provider , $setOnInsert , $set ) => { // assign default metadata upon registration $setOnInsert . metadata = { coins : 100 , trophies : 0 }; }); hooks.beforeUserUpdate \u00b6 The beforeUserUpdate hooks is triggered before a user update his own information through the save() method . import Filter from \"bad-words\" ; const filter = new Filter (); hooks . beforeUserUpdate (( _id , fields ) => { if ( fields [ 'username' ] && filter . isProfane ( fields [ 'username' ])) { throw new Error ( \"no_swearing_allowed\" ); } }) Client-side API \u00b6 Login \u00b6 Anonymous Email + Password Facebook Anonymous \u00b6 JavaScript await client . auth . login (); C# await client . Auth . Login (); lua client . auth : login ( function ( err , auth ) -- ... end ); Email + Password \u00b6 JavaScript await client . auth . login ({ email : \"user@example.com\" , password : \"12345\" }); C# await client . Auth . Login ( \"user@example.com\" , \"12345\" ); lua client . auth : login ({ email = \"user@example.com\" , password = \"12345\" }, function ( err , auth ) -- ... end ) Facebook \u00b6 JavaScript // // Make sure you have the Facebook SDK installed and configured first // - https://developers.facebook.com/docs/javascript/quickstart // - https://developers.facebook.com/docs/facebook-login/web // FB . login ( function ( response ) { if ( response . authResponse ) { client . auth . login ({ accessToken : response . authResponse . accessToken }); } }, { scope : 'public_profile,email,user_friends' }); C# // // Make sure you have the Facebook SDK installed and configured first // - https://developers.facebook.com/docs/unity/gettingstarted // - https://developers.facebook.com/docs/unity/examples#login // var perms = new List < string >(){ \"public_profile\" , \"email\" , \"user_friends\" }; FB . LogInWithReadPermissions ( perms , AuthCallback ); private void AuthCallback ( ILoginResult result ) { if ( FB . IsLoggedIn ) { client . Auth . Login ( Facebook . Unity . AccessToken . CurrentAccessToken ); } } lua client . auth : facebook_login ( function ( err , auth ) pprint ( auth ) end ) Update User Data \u00b6 You can modify the username , displayName , avatarUrl , lang , location , and timezone from the client-side, and then call the save() method. JavaScript client . auth . username = \"Hello world!\" await client . auth . save (); C# client . Auth . Username = \"Hello world!\" ; await client . Auth . Save (); lua client . auth . username = \"Hello world!\" client . auth : save () Logout \u00b6 JavaScript client . auth . logout (); C# client . Auth . Logout (); lua client . auth : logout (); Get Friends \u00b6 JavaScript const friends = await client . auth . getFriends (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetFriends (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_friends ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end ); Get Online Friends \u00b6 JavaScript const friends = await client . auth . getOnlineFriends (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetOnlineFriends (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_online_friends ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end ); Get Friend Requests \u00b6 JavaScript const friends = await client . auth . getFriendRequests (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetFriendRequests (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_friend_requests ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end ); Accept Friend Request \u00b6 JavaScript await client . auth . acceptFriendRequest ( friendId ); C# await client . Auth . AcceptFriendRequest ( friendId ); lua client . auth : accept_friend_request ( friend_id ) Decline Friend Request \u00b6 JavaScript await client . auth . declineFriendRequest ( friendId ); C# await client . Auth . DeclineFriendRequest ( friendId ); lua client . auth : decline_friend_request ( friend_id ) Send Friend Request \u00b6 JavaScript await client . auth . sendFriendRequest ( friendId ); C# await client . Auth . SendFriendRequest ( friendId ); lua client . auth : send_friend_request ( friend_id ) Block User \u00b6 JavaScript await client . auth . blockUser ( friendId ); C# await client . Auth . BlockUser ( friendId ); lua client . auth : block_user ( friend_id ) Unblock User \u00b6 JavaScript await client . auth . unblockUser ( friendId ); C# await client . Auth . UnblockUser ( friendId ); lua client . auth : unblock_user ( friend_id )","title":"Authentication"},{"location":"authentication/#installation","text":"Download and install MongoDB Install the @colyseus/social module. npm install @colyseus/social npm install express-jwt Import and expose the Express routes provided by @colyseus/social . import express from \"express\" ; import socialRoutes from \"@colyseus/social/express\" const app = express (); app . use ( \"/\" , socialRoutes ); app . listen ( 8080 );","title":"Installation"},{"location":"authentication/#server-side-configuration","text":"","title":"Server-side configuration"},{"location":"authentication/#environment-variables","text":"MONGO_URI : MongoDB connection URI JWT_SECRET : Secure secret string for authentication. FACEBOOK_APP_TOKEN : Facebook App Token ( \"appid|appsecret\" )","title":"Environment Variables"},{"location":"authentication/#server-side-api","text":"The @colyseus/social module provides the MongoDB models, and the token validation function available for you to use. import { User , FriendRequest , verifyToken } from \"@colyseus/social\" ;","title":"Server-side API"},{"location":"authentication/#implementing-onauth-to-retrieve-the-current-user","text":"import { User , verifyToken } from \"@colyseus/social\" ; class MyRoom extends Room { async onAuth ( client , options ) { // verify token authenticity const token = verifyToken ( options . token ); // query the user by its id return await User . findById ( token . _id ); } onJoin ( client , options , user ) { console . log ( user . username , \"has joined the room!\" ); } }","title":"Implementing onAuth to retrieve the current user"},{"location":"authentication/#hooks","text":"","title":"Hooks"},{"location":"authentication/#hooksbeforeauthenticate","text":"The beforeAuthenticate hook is triggered before a user logs in or registers. import { hooks } from \"@colyseus/social\" ; hooks . beforeAuthenticate (( provider , $setOnInsert , $set ) => { // assign default metadata upon registration $setOnInsert . metadata = { coins : 100 , trophies : 0 }; });","title":"hooks.beforeAuthenticate"},{"location":"authentication/#hooksbeforeuserupdate","text":"The beforeUserUpdate hooks is triggered before a user update his own information through the save() method . import Filter from \"bad-words\" ; const filter = new Filter (); hooks . beforeUserUpdate (( _id , fields ) => { if ( fields [ 'username' ] && filter . isProfane ( fields [ 'username' ])) { throw new Error ( \"no_swearing_allowed\" ); } })","title":"hooks.beforeUserUpdate"},{"location":"authentication/#client-side-api","text":"","title":"Client-side API"},{"location":"authentication/#login","text":"Anonymous Email + Password Facebook","title":"Login"},{"location":"authentication/#anonymous","text":"JavaScript await client . auth . login (); C# await client . Auth . Login (); lua client . auth : login ( function ( err , auth ) -- ... end );","title":"Anonymous"},{"location":"authentication/#email-password","text":"JavaScript await client . auth . login ({ email : \"user@example.com\" , password : \"12345\" }); C# await client . Auth . Login ( \"user@example.com\" , \"12345\" ); lua client . auth : login ({ email = \"user@example.com\" , password = \"12345\" }, function ( err , auth ) -- ... end )","title":"Email + Password"},{"location":"authentication/#facebook","text":"JavaScript // // Make sure you have the Facebook SDK installed and configured first // - https://developers.facebook.com/docs/javascript/quickstart // - https://developers.facebook.com/docs/facebook-login/web // FB . login ( function ( response ) { if ( response . authResponse ) { client . auth . login ({ accessToken : response . authResponse . accessToken }); } }, { scope : 'public_profile,email,user_friends' }); C# // // Make sure you have the Facebook SDK installed and configured first // - https://developers.facebook.com/docs/unity/gettingstarted // - https://developers.facebook.com/docs/unity/examples#login // var perms = new List < string >(){ \"public_profile\" , \"email\" , \"user_friends\" }; FB . LogInWithReadPermissions ( perms , AuthCallback ); private void AuthCallback ( ILoginResult result ) { if ( FB . IsLoggedIn ) { client . Auth . Login ( Facebook . Unity . AccessToken . CurrentAccessToken ); } } lua client . auth : facebook_login ( function ( err , auth ) pprint ( auth ) end )","title":"Facebook"},{"location":"authentication/#update-user-data","text":"You can modify the username , displayName , avatarUrl , lang , location , and timezone from the client-side, and then call the save() method. JavaScript client . auth . username = \"Hello world!\" await client . auth . save (); C# client . Auth . Username = \"Hello world!\" ; await client . Auth . Save (); lua client . auth . username = \"Hello world!\" client . auth : save ()","title":"Update User Data"},{"location":"authentication/#logout","text":"JavaScript client . auth . logout (); C# client . Auth . Logout (); lua client . auth : logout ();","title":"Logout"},{"location":"authentication/#get-friends","text":"JavaScript const friends = await client . auth . getFriends (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetFriends (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_friends ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end );","title":"Get Friends"},{"location":"authentication/#get-online-friends","text":"JavaScript const friends = await client . auth . getOnlineFriends (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetOnlineFriends (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_online_friends ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end );","title":"Get Online Friends"},{"location":"authentication/#get-friend-requests","text":"JavaScript const friends = await client . auth . getFriendRequests (); friends . forEach ( friend => { console . log ( friend . username ); }); C# var friends = await client . Auth . GetFriendRequests (); for ( var i = 0 ; i < friends . Length ; i ++) { Debug . Log ( friends [ i ]. Username ); } lua client . auth : get_friend_requests ( function ( err , friends ) for i , friend in pairs ( friends ) do print ( friend . username ) end end );","title":"Get Friend Requests"},{"location":"authentication/#accept-friend-request","text":"JavaScript await client . auth . acceptFriendRequest ( friendId ); C# await client . Auth . AcceptFriendRequest ( friendId ); lua client . auth : accept_friend_request ( friend_id )","title":"Accept Friend Request"},{"location":"authentication/#decline-friend-request","text":"JavaScript await client . auth . declineFriendRequest ( friendId ); C# await client . Auth . DeclineFriendRequest ( friendId ); lua client . auth : decline_friend_request ( friend_id )","title":"Decline Friend Request"},{"location":"authentication/#send-friend-request","text":"JavaScript await client . auth . sendFriendRequest ( friendId ); C# await client . Auth . SendFriendRequest ( friendId ); lua client . auth : send_friend_request ( friend_id )","title":"Send Friend Request"},{"location":"authentication/#block-user","text":"JavaScript await client . auth . blockUser ( friendId ); C# await client . Auth . BlockUser ( friendId ); lua client . auth : block_user ( friend_id )","title":"Block User"},{"location":"authentication/#unblock-user","text":"JavaScript await client . auth . unblockUser ( friendId ); C# await client . Auth . UnblockUser ( friendId ); lua client . auth : unblock_user ( friend_id )","title":"Unblock User"},{"location":"debugging/","text":"Inspector ( --inspect flag) Debug messages Inspector \u00b6 You can use the the built-in inspector from Node.js to debug your application. Tip Read more about Debugging Node.js Applications . Using the inspector on production environment \u00b6 Be careful when using the inspector on production. Using memory snapshots and breakpoints will impact the experience of your users directly. 1. Connect to the remote server: ssh root@remote.example.com 2. Check the PID of the Node process ps aux | grep node 3. Attach the inspector on the process kill -usr1 PID 4. Create a SSH tunnel from your local machine to the remote inspector ssh -L 9229:localhost:9229 root@remote.example.com Your production server should now appear on chrome://inspect . Debug messages \u00b6 The server provides some debug messages that you can enable individually per category, by setting the DEBUG environment variable. To enable all logs, you can run your server using: DEBUG=colyseus:* node server.js See below all available debug categories with sample outputs. colyseus:patch \u00b6 Logs the number of bytes and interval between patches broadcasted to all clients. colyseus:patch \"chat\" (roomId: \"ryWiL5rLTZ\") is sending 28 bytes: +57ms colyseus:errors \u00b6 Logs whenever unexpected (or expected, internally) errors happens on the server-side. colyseus:matchmaking \u00b6 Logs whenever a room is spanwed or disposed. colyseus:matchmaking spawning 'chat' on worker 77218 +52s colyseus:matchmaking disposing 'chat' on worker 77218 +2s","title":"Debugging"},{"location":"debugging/#inspector","text":"You can use the the built-in inspector from Node.js to debug your application. Tip Read more about Debugging Node.js Applications .","title":"Inspector"},{"location":"debugging/#using-the-inspector-on-production-environment","text":"Be careful when using the inspector on production. Using memory snapshots and breakpoints will impact the experience of your users directly. 1. Connect to the remote server: ssh root@remote.example.com 2. Check the PID of the Node process ps aux | grep node 3. Attach the inspector on the process kill -usr1 PID 4. Create a SSH tunnel from your local machine to the remote inspector ssh -L 9229:localhost:9229 root@remote.example.com Your production server should now appear on chrome://inspect .","title":"Using the inspector on production environment"},{"location":"debugging/#debug-messages","text":"The server provides some debug messages that you can enable individually per category, by setting the DEBUG environment variable. To enable all logs, you can run your server using: DEBUG=colyseus:* node server.js See below all available debug categories with sample outputs.","title":"Debug messages"},{"location":"debugging/#colyseuspatch","text":"Logs the number of bytes and interval between patches broadcasted to all clients. colyseus:patch \"chat\" (roomId: \"ryWiL5rLTZ\") is sending 28 bytes: +57ms","title":"colyseus:patch"},{"location":"debugging/#colyseuserrors","text":"Logs whenever unexpected (or expected, internally) errors happens on the server-side.","title":"colyseus:errors"},{"location":"debugging/#colyseusmatchmaking","text":"Logs whenever a room is spanwed or disposed. colyseus:matchmaking spawning 'chat' on worker 77218 +52s colyseus:matchmaking disposing 'chat' on worker 77218 +2s","title":"colyseus:matchmaking"},{"location":"deployment/","text":"Deploying on Heroku Deploying on Nginx (recommended) Deploying on Apache Using greenlock-express Heroku \u00b6 Heroku is recommended just for prototyping. You can deploy the colyseus-examples project on it by hitting this button: Nginx (recommended) \u00b6 It's recommended to use pm2 and nginx in your production environment. PM2 \u00b6 Install pm2 in your environment. npm install -g pm2 Then start your game server using it: pm2 start your-server.js Nginx configuration \u00b6 server { listen 80; server_name yourdomain.com; location / { proxy_pass http://localhost:2567; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_read_timeout 86400s; proxy_send_timeout 86400s; } } Nginx configuration with SSL \u00b6 It's recommended to acquire your certificate from LetsEncrypt . server { listen 80; listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/your/cert.crt; ssl_certificate_key /path/to/your/cert.key; location / { proxy_pass http://localhost:2567; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_read_timeout 86400s; proxy_send_timeout 86400s; } } Apache \u00b6 Here's how to use Apache as a proxy to your Node.js Colyseus app. (Thanks tomkleine !) Install the required Apache modules: sudo a2enmod ssl sudo a2enmod proxy sudo a2enmod proxy_http sudo a2enmod proxy_html sudo a2enmod proxy_wstunnel Virtual host configuration: <VirtualHost *:80> ServerName servername.xyz # Redirect all requests received from port 80 to the HTTPS variant (force ssl) RewriteEngine On RewriteRule ^(.*)$ https://%{HTTP_HOST}$1 [R=301,L] </VirtualHost> <VirtualHost *:443> ServerName servername.xyz # enable SSL SSLEngine On SSLCertificateFile /PATH/TO/CERT/FILE SSLCertificateKeyFile /PATH/TO/PRIVATE/KEY/FILE # # setup the proxy to forward websocket requests properly to a normal websocket # and vice versa, so there's no need to change the colyseus library or the # server for that matter) # # (note: this proxy automatically converts the secure websocket (wss) RewriteEngine On RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC,OR] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:APP-PORT-HERE%{REQUEST_URI} [P,QSA,L] # setup the proxy to forward all https requests to http backend # (also automatic conversion from https to http and vice versa) ProxyPass \"/\" \"http://localhost:APP-PORT-HERE/\" ProxyPassReverse \"/\" \"http://localhost:APP-PORT-HERE/\" </VirtualHost> greenlock-express \u00b6 When using greenlock-express , you should not have any reverse-proxy configured behind it, such as Nginx or Apache . Please follow greenlock-express's README section first . Here's the recommended way to handle both development and production environments if you decide to use greenlock-express : import http from \"http\" ; import express from \"express\" ; import { Server } from \"colyseus\" ; function setup ( app : express.Application , server : http.Server ) { const gameServer = new Server ({ server }); // TODO: configure `app` and `gameServer` accourding to your needs. // gameServer.define(\"room\", YourRoom); return app ; } if ( process . env . NODE_ENV === \"production\" ) { require ( 'greenlock-express' ) . init ( function () { return { greenlock : require ( './greenlock' ), cluster : false }; }) . ready ( function ( glx ) { const app = express (); // Serves on 80 and 443 // Get's SSL certificates magically! glx . serveApp ( setup ( app , glx . httpsServer ( undefined , app ))); }); } else { // development port const PORT = process . env . PORT || 2567 ; const app = express (); const server = http . createServer ( app ); setup ( app , server ); server . listen ( PORT , () => console . log ( `Listening on http://localhost: ${ PORT } ` )); }","title":"Deployment"},{"location":"deployment/#heroku","text":"Heroku is recommended just for prototyping. You can deploy the colyseus-examples project on it by hitting this button:","title":"Heroku"},{"location":"deployment/#nginx-recommended","text":"It's recommended to use pm2 and nginx in your production environment.","title":"Nginx (recommended)"},{"location":"deployment/#pm2","text":"Install pm2 in your environment. npm install -g pm2 Then start your game server using it: pm2 start your-server.js","title":"PM2"},{"location":"deployment/#nginx-configuration","text":"server { listen 80; server_name yourdomain.com; location / { proxy_pass http://localhost:2567; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_read_timeout 86400s; proxy_send_timeout 86400s; } }","title":"Nginx configuration"},{"location":"deployment/#nginx-configuration-with-ssl","text":"It's recommended to acquire your certificate from LetsEncrypt . server { listen 80; listen 443 ssl; server_name yourdomain.com; ssl_certificate /path/to/your/cert.crt; ssl_certificate_key /path/to/your/cert.key; location / { proxy_pass http://localhost:2567; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_read_timeout 86400s; proxy_send_timeout 86400s; } }","title":"Nginx configuration with SSL"},{"location":"deployment/#apache","text":"Here's how to use Apache as a proxy to your Node.js Colyseus app. (Thanks tomkleine !) Install the required Apache modules: sudo a2enmod ssl sudo a2enmod proxy sudo a2enmod proxy_http sudo a2enmod proxy_html sudo a2enmod proxy_wstunnel Virtual host configuration: <VirtualHost *:80> ServerName servername.xyz # Redirect all requests received from port 80 to the HTTPS variant (force ssl) RewriteEngine On RewriteRule ^(.*)$ https://%{HTTP_HOST}$1 [R=301,L] </VirtualHost> <VirtualHost *:443> ServerName servername.xyz # enable SSL SSLEngine On SSLCertificateFile /PATH/TO/CERT/FILE SSLCertificateKeyFile /PATH/TO/PRIVATE/KEY/FILE # # setup the proxy to forward websocket requests properly to a normal websocket # and vice versa, so there's no need to change the colyseus library or the # server for that matter) # # (note: this proxy automatically converts the secure websocket (wss) RewriteEngine On RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC,OR] RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC] RewriteRule .* ws://127.0.0.1:APP-PORT-HERE%{REQUEST_URI} [P,QSA,L] # setup the proxy to forward all https requests to http backend # (also automatic conversion from https to http and vice versa) ProxyPass \"/\" \"http://localhost:APP-PORT-HERE/\" ProxyPassReverse \"/\" \"http://localhost:APP-PORT-HERE/\" </VirtualHost>","title":"Apache"},{"location":"deployment/#greenlock-express","text":"When using greenlock-express , you should not have any reverse-proxy configured behind it, such as Nginx or Apache . Please follow greenlock-express's README section first . Here's the recommended way to handle both development and production environments if you decide to use greenlock-express : import http from \"http\" ; import express from \"express\" ; import { Server } from \"colyseus\" ; function setup ( app : express.Application , server : http.Server ) { const gameServer = new Server ({ server }); // TODO: configure `app` and `gameServer` accourding to your needs. // gameServer.define(\"room\", YourRoom); return app ; } if ( process . env . NODE_ENV === \"production\" ) { require ( 'greenlock-express' ) . init ( function () { return { greenlock : require ( './greenlock' ), cluster : false }; }) . ready ( function ( glx ) { const app = express (); // Serves on 80 and 443 // Get's SSL certificates magically! glx . serveApp ( setup ( app , glx . httpsServer ( undefined , app ))); }); } else { // development port const PORT = process . env . PORT || 2567 ; const app = express (); const server = http . createServer ( app ); setup ( app , server ); server . listen ( PORT , () => console . log ( `Listening on http://localhost: ${ PORT } ` )); }","title":"greenlock-express"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 How many CCU a Colyseus server can handle?! \u00b6 The maximum number of concurrent users (CCU) a Colyseus server can handle will vary accourding to how CPU-intensive your game loop is, and how much traffic your server is sending back to the clients. The default \"file descriptor limit\" (amount of open connections you can have) of Linux servers is around 1024 - this value can be increased at your own risk. So, you can safely assume the cheapest cloud server is capable of holding 1024 concurrent connections. There are reports of people managing to have up to 600k open WebSocket connections , even though they're idle connections, without transferring data - it proves you can potentially handle more than 1024 concurrent connections by fine tuning the server specs and configuration. How can I sync data of the state only to a specific client? \u00b6 In the current state of the framework, you can't do that. You'd need to send data manually to each client (through room's send method ), and not use the state for the data you'd like to hide from particular players. There's a big discussion about this on issue #59 Hopefully this will be improved when the new serialization gets stable, and integrated with the framework. How would I broadcast data from one client to others? \u00b6 You usually don't do that. By using an authoritative game server, the clients generally send actions to the server, and the server mutates the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval. Does Colyseus help me with client-prediction? \u00b6 Colyseus does not provide any client-prediction solution out of the box. Games such as wilds.io and mazmorra.io do not use any form of client-prediction. lerp ing user coordinates usually gives reasonable results. I'm getting this error: Class constructor Room cannot be invoked without 'new'\" , what should I do? \u00b6 Make sure you have es2015 or higher in your tsconfig.json : { \"compilerOptions\" : { // ... \"target\" : \"es2015\" , // ... }, // ... }","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#how-many-ccu-a-colyseus-server-can-handle","text":"The maximum number of concurrent users (CCU) a Colyseus server can handle will vary accourding to how CPU-intensive your game loop is, and how much traffic your server is sending back to the clients. The default \"file descriptor limit\" (amount of open connections you can have) of Linux servers is around 1024 - this value can be increased at your own risk. So, you can safely assume the cheapest cloud server is capable of holding 1024 concurrent connections. There are reports of people managing to have up to 600k open WebSocket connections , even though they're idle connections, without transferring data - it proves you can potentially handle more than 1024 concurrent connections by fine tuning the server specs and configuration.","title":"How many CCU a Colyseus server can handle?!"},{"location":"faq/#how-can-i-sync-data-of-the-state-only-to-a-specific-client","text":"In the current state of the framework, you can't do that. You'd need to send data manually to each client (through room's send method ), and not use the state for the data you'd like to hide from particular players. There's a big discussion about this on issue #59 Hopefully this will be improved when the new serialization gets stable, and integrated with the framework.","title":"How can I sync data of the state only to a specific client?"},{"location":"faq/#how-would-i-broadcast-data-from-one-client-to-others","text":"You usually don't do that. By using an authoritative game server, the clients generally send actions to the server, and the server mutates the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.","title":"How would I broadcast data from one client to others?"},{"location":"faq/#does-colyseus-help-me-with-client-prediction","text":"Colyseus does not provide any client-prediction solution out of the box. Games such as wilds.io and mazmorra.io do not use any form of client-prediction. lerp ing user coordinates usually gives reasonable results.","title":"Does Colyseus help me with client-prediction?"},{"location":"faq/#im-getting-this-error-class-constructor-room-cannot-be-invoked-without-new-what-should-i-do","text":"Make sure you have es2015 or higher in your tsconfig.json : { \"compilerOptions\" : { // ... \"target\" : \"es2015\" , // ... }, // ... }","title":"I'm getting this error: Class constructor Room cannot be invoked without 'new'\", what should I do?"},{"location":"formatting/","text":"Important This is a warning Tip this is a tip Server configuration This is a note Tabs with code \u00b6 Here's some tabs for you. TypeScript // TypeScript JavaScript // JavaScript C# // c-sharp","title":"Formatting"},{"location":"formatting/#tabs-with-code","text":"Here's some tabs for you. TypeScript // TypeScript JavaScript // JavaScript C# // c-sharp","title":"Tabs with code"},{"location":"matchmaking/","text":"The requestJoin() method has been removed from version 0.11 . See Server#define() for new matchmaking system.","title":"Matchmaking"},{"location":"push/","text":"Push notifications are part of @colyseus/social . They're experimental and not fully functional. Currently, only Web Push is supported. Environment variables \u00b6 WEBPUSH_SUBJECT - mailto: or URL. WEBPUSH_PUBLIC_KEY - VAPID Public Key WEBPUSH_PRIVATE_KEY - VAPID Private Key You can generate VAPID keys using npx web-push generate-vapid-keys","title":"Push Notifications"},{"location":"push/#environment-variables","text":"WEBPUSH_SUBJECT - mailto: or URL. WEBPUSH_PUBLIC_KEY - VAPID Public Key WEBPUSH_PRIVATE_KEY - VAPID Private Key You can generate VAPID keys using npx web-push generate-vapid-keys","title":"Environment variables"},{"location":"scalability/","text":"This document is a work-in-progress. To scale Colyseus into multiple processes or servers, you'll need to have Redis, MongoDB, and a dynamic proxy. Redis \u00b6 Download and install Redis . Use the RedisPresence : TypeScript import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... presence : new RedisPresence (), }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence (), }); The presence is used to call room \"seat reservation\" functions from one process to another, and allows the developer to take advantage of the some data sharing functions across rooms. See Presence API . Each Colyseus process also registers its own processId and network location to the presence API, which is later used by the dynamic proxy service. During graceful shutdown, the process unregisters itself. MongoDB \u00b6 Download and install MongoDB . And install the mongoose package: npm install --save mongoose Use the MongooseDriver : TypeScript import { Server , RedisPresence } from \"colyseus\" ; import { MongooseDriver } from \"colyseus/lib/matchmaker/drivers/MongooseDriver\" const gameServer = new Server ({ // ... driver : new MongooseDriver (), }); JavaScript const colyseus = require ( \"colyseus\" ); const MongooseDriver = require ( \"colyseus/lib/matchmaker/drivers/MongooseDriver\" ). MongooseDriver ; const gameServer = new colyseus . Server ({ // ... driver : new MongooseDriver (), }); You can either pass the MongoDB connection URI to the new MongooseDriver(uri) constructor, or set a MONGO_URI environment variable. The driver is used to store and query available rooms for matchmaking. Running multiple Colyseus processes \u00b6 To run multiple Colyseus instances in the same server, you need each one of them to listen on a different port number. It's recommended to use ports 3001 , 3002 , 3003 , and so on. The Colyseus processes should NOT be exposed publicly. Only the dynamic proxy is. The PM2 process manager is highly recommended for managing multiple Node.js app instances. PM2 provides a NODE_APP_INSTANCE environment variable, containing a different number for each process. Use it to define your port number. Typescript import { Server } from \"colyseus\" ; // binds each instance of the server on a different port. const PORT = Number ( process . env . PORT ) + Number ( process . env . NODE_APP_INSTANCE ); const gameServer = new Server ({ /* ... */ }) gameServer . listen ( PORT ); console . log ( \"Listening on\" , PORT ); npm install -g pm2 Use the following ecosystem.config.js configuration: // ecosystem.config.js const os = require ( 'os' ); module . exports = { apps : [{ port : 3000 , name : \"colyseus\" , script : \"lib/index.js\" , // your entrypoint file watch : true , // optional instances : os . cpus (). length , exec_mode : 'fork' , // IMPORTANT: do not use cluster mode. env : { DEBUG : \"colyseus:errors\" , NODE_ENV : \"production\" , } }] } Now you're ready to start multiple Colyseus proceses. pm2 start PM2 and TypeScript It's recommended compile your .ts files before running pm2 start , via npx tsc . Alternatively, you can install the TypeScript interpreter for PM2 ( pm2 install typescript ) and set the exec_interpreter: \"ts-node\" ( read more ). Dynamic proxy \u00b6 The @colyseus/proxy is a dynamic proxy that automatically listens whenever a Colyseus process goes up and down, allowing the WebSocket connections to go to the right process and server where a room has been created on. The proxy should be bound to port 80 / 443 as it is the only public endpoint you'll have for your application. All requests must go through the proxy. npm install -g @colyseus/proxy Environment variables \u00b6 Configure the following environment variables to meet your needs: PORT is the port the proxy will be running on. REDIS_URL is the path to the same Redis instance you're using on Colyseus' processes. Running the proxy \u00b6 colyseus-proxy > {\"name\":\"redbird\",\"hostname\":\"Endels-MacBook-Air.local\",\"pid\":33390,\"level\":30,\"msg\":\"Started a Redbird reverse proxy server on port 80\",\"time\":\"2019-08-20T15:26:19.605Z\",\"v\":0}","title":"Scalability"},{"location":"scalability/#redis","text":"Download and install Redis . Use the RedisPresence : TypeScript import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... presence : new RedisPresence (), }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence (), }); The presence is used to call room \"seat reservation\" functions from one process to another, and allows the developer to take advantage of the some data sharing functions across rooms. See Presence API . Each Colyseus process also registers its own processId and network location to the presence API, which is later used by the dynamic proxy service. During graceful shutdown, the process unregisters itself.","title":"Redis"},{"location":"scalability/#mongodb","text":"Download and install MongoDB . And install the mongoose package: npm install --save mongoose Use the MongooseDriver : TypeScript import { Server , RedisPresence } from \"colyseus\" ; import { MongooseDriver } from \"colyseus/lib/matchmaker/drivers/MongooseDriver\" const gameServer = new Server ({ // ... driver : new MongooseDriver (), }); JavaScript const colyseus = require ( \"colyseus\" ); const MongooseDriver = require ( \"colyseus/lib/matchmaker/drivers/MongooseDriver\" ). MongooseDriver ; const gameServer = new colyseus . Server ({ // ... driver : new MongooseDriver (), }); You can either pass the MongoDB connection URI to the new MongooseDriver(uri) constructor, or set a MONGO_URI environment variable. The driver is used to store and query available rooms for matchmaking.","title":"MongoDB"},{"location":"scalability/#running-multiple-colyseus-processes","text":"To run multiple Colyseus instances in the same server, you need each one of them to listen on a different port number. It's recommended to use ports 3001 , 3002 , 3003 , and so on. The Colyseus processes should NOT be exposed publicly. Only the dynamic proxy is. The PM2 process manager is highly recommended for managing multiple Node.js app instances. PM2 provides a NODE_APP_INSTANCE environment variable, containing a different number for each process. Use it to define your port number. Typescript import { Server } from \"colyseus\" ; // binds each instance of the server on a different port. const PORT = Number ( process . env . PORT ) + Number ( process . env . NODE_APP_INSTANCE ); const gameServer = new Server ({ /* ... */ }) gameServer . listen ( PORT ); console . log ( \"Listening on\" , PORT ); npm install -g pm2 Use the following ecosystem.config.js configuration: // ecosystem.config.js const os = require ( 'os' ); module . exports = { apps : [{ port : 3000 , name : \"colyseus\" , script : \"lib/index.js\" , // your entrypoint file watch : true , // optional instances : os . cpus (). length , exec_mode : 'fork' , // IMPORTANT: do not use cluster mode. env : { DEBUG : \"colyseus:errors\" , NODE_ENV : \"production\" , } }] } Now you're ready to start multiple Colyseus proceses. pm2 start PM2 and TypeScript It's recommended compile your .ts files before running pm2 start , via npx tsc . Alternatively, you can install the TypeScript interpreter for PM2 ( pm2 install typescript ) and set the exec_interpreter: \"ts-node\" ( read more ).","title":"Running multiple Colyseus processes"},{"location":"scalability/#dynamic-proxy","text":"The @colyseus/proxy is a dynamic proxy that automatically listens whenever a Colyseus process goes up and down, allowing the WebSocket connections to go to the right process and server where a room has been created on. The proxy should be bound to port 80 / 443 as it is the only public endpoint you'll have for your application. All requests must go through the proxy. npm install -g @colyseus/proxy","title":"Dynamic proxy"},{"location":"scalability/#environment-variables","text":"Configure the following environment variables to meet your needs: PORT is the port the proxy will be running on. REDIS_URL is the path to the same Redis instance you're using on Colyseus' processes.","title":"Environment variables"},{"location":"scalability/#running-the-proxy","text":"colyseus-proxy > {\"name\":\"redbird\",\"hostname\":\"Endels-MacBook-Air.local\",\"pid\":33390,\"level\":30,\"msg\":\"Started a Redbird reverse proxy server on port 80\",\"time\":\"2019-08-20T15:26:19.605Z\",\"v\":0}","title":"Running the proxy"},{"location":"client/client/","text":"Overview \u00b6 Colyseus currently have clients for the platforms: HTML5 ( colyseus/colyseus.js ) Unity3D ( colyseus/colyseus-unity3d ) Defold ( colyseus/colyseus-defold ) Haxe ( colyseus/colyseus-hx ) Cocos2d-X ( colyseus/colyseus-cocos2d-x ) Construct3 ( colyseus/colyseus-construct3 ) Need a client for another platform? Share your interest on the discussion board ! Connecting to the Server \u00b6 JavaScript import Colyseus from \"colyseus.js\" ; // ... let client = new Colyseus . Client ( \"ws://localhost:2567\" ); C# using Colyseus ; // ... Client client = new Client ( \"ws://localhost:2567\" ); lua local ColyseusClient = require ( \"colyseus.client\" ) // ... local client = ColyseusClient . new ( \"ws://localhost:2567\" ); Haxe import io . colyseus . Client ; // ... var client = new Client ( \"ws://localhost:2567\" ); Methods \u00b6 joinOrCreate (roomName: string, options: any) \u00b6 Join an existing room or create a new one, by provided roomName and options . Locked or private rooms are ignored by this method. JavaScript client . joinOrCreate ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinOrCreate < YourStateClass >( \"battle\" /* , Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_or_create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinOrCreate ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinOrCreate < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); create (roomName: string, options: any) \u00b6 Creates a new room by provided roomName and options . JavaScript client . create ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Create < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . create ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> create < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); join (roomName: string, options: any) \u00b6 Joins an existing room by provided roomName and options . Locked or private rooms are ignored by this method. JavaScript client . join ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Join < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . join ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> join < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); joinById (roomId: string, options: any) \u00b6 Joins an existing room by its roomId . Private rooms can be joined by id. JavaScript client . joinById ( \"KRYAKzRo2\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinById < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_by_id ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinById ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinById < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); Tip Use getAvailableRooms() to retrieve a list of roomId 's available for joining. reconnect (roomId: string, sessionId: string) \u00b6 Reconnects the client into a room he was previously connected with. Must be used along with allowReconnection() in the server-side. JavaScript let room = client . reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" ). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Reconnect < YourStateClass >( \"wNHTX5qik\" , \"SkNaHTazQ\" ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" , function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" , YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client - > reconnect < YourStateClass > ( \"wNHTX5qik\" , \"SkNaHTazQ\", [=](std::string err, Room<State>* room ) { if ( err != \"\" ) { std : : cout << \"join error: \" << err << std ::endl; return; } std :: cout << \"joined successfully\" << std :: endl ; } ); getAvailableRooms (roomName?: string) \u00b6 List all available rooms to connect. Locked and private rooms won't be listed. roomName is optional. JavaScript client . getAvailableRooms ( \"battle\" ). then ( rooms => { rooms . forEach (( room ) => { console . log ( room . roomId ); console . log ( room . clients ); console . log ( room . maxClients ); console . log ( room . metadata ); }); }). catch ( e => { console . error ( e ); }); C# try { var rooms = await client . GetAvailableRooms ( \"battle\" ); for ( int i = 0 ; i < rooms . Length ; i ++) { Debug . Log ( rooms [ i ]. roomId ); Debug . Log ( rooms [ i ]. clients ); Debug . Log ( rooms [ i ]. maxClients ); Debug . Log ( rooms [ i ]. metadata ); } } catch ( ex ) { Debug . Log ( ex . Message ) } /** * Retrieving custom metadata */ [Serializable] class Metadata { public string mode ; public string name ; } [Serializable] class CustomRoomAvailable : RoomAvailable { public Metadata metadata ; } var rooms = await client . GetAvailableRooms < CustomRoomAvailable >( \"battle\" ); Debug . Log ( rooms [ 0 ]. metadata . mode ); lua client : get_available_rooms ( \"battle\" , function ( err , rooms ) if ( err ) then console . error ( err ); return end for i , rooms in pairs ( rooms ) do print ( rooms [ i ]. roomId ) print ( rooms [ i ]. clients ) print ( rooms [ i ]. maxClients ) print ( rooms [ i ]. metadata ) end end ); Haxe client . getAvailableRooms ( \"battle\" , function ( err , rooms ) { if ( err != null ) { trace ( err ); return ; } for ( room in rooms ) { trace ( room . roomId ); trace ( room . clients ); trace ( room . maxClients ); trace ( room . metadata ); } }); C++ client . getAvailableRooms ( \"battle\" , [ = ]( std :: string err , nlohmann :: json rooms ) { if ( err != \"\" ) { std :: cout << \"error: \" << err << std :: endl ; return ; } // rooms }); consumeSeatReservation (reservation) \u00b6 Join a room by consuming a seat reservation. Advanced usage See Match-maker API to see how to retrieve the seat reservation data. JavaScript client . consumeSeatReservation ( reservation ). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . ConsumeSeatReservation < YourStateClass >( reservation ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : consume_seat_reservation ( reservation , function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . consumeSeatReservation ( reservation , YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> consumeSeatReservation < YourStateClass > ( reservation , [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; });","title":"Client"},{"location":"client/client/#overview","text":"Colyseus currently have clients for the platforms: HTML5 ( colyseus/colyseus.js ) Unity3D ( colyseus/colyseus-unity3d ) Defold ( colyseus/colyseus-defold ) Haxe ( colyseus/colyseus-hx ) Cocos2d-X ( colyseus/colyseus-cocos2d-x ) Construct3 ( colyseus/colyseus-construct3 ) Need a client for another platform? Share your interest on the discussion board !","title":"Overview"},{"location":"client/client/#connecting-to-the-server","text":"JavaScript import Colyseus from \"colyseus.js\" ; // ... let client = new Colyseus . Client ( \"ws://localhost:2567\" ); C# using Colyseus ; // ... Client client = new Client ( \"ws://localhost:2567\" ); lua local ColyseusClient = require ( \"colyseus.client\" ) // ... local client = ColyseusClient . new ( \"ws://localhost:2567\" ); Haxe import io . colyseus . Client ; // ... var client = new Client ( \"ws://localhost:2567\" );","title":"Connecting to the Server"},{"location":"client/client/#methods","text":"","title":"Methods"},{"location":"client/client/#joinorcreate-roomname-string-options-any","text":"Join an existing room or create a new one, by provided roomName and options . Locked or private rooms are ignored by this method. JavaScript client . joinOrCreate ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinOrCreate < YourStateClass >( \"battle\" /* , Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_or_create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinOrCreate ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinOrCreate < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; });","title":"joinOrCreate (roomName: string, options: any)"},{"location":"client/client/#create-roomname-string-options-any","text":"Creates a new room by provided roomName and options . JavaScript client . create ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Create < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . create ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> create < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; });","title":"create (roomName: string, options: any)"},{"location":"client/client/#join-roomname-string-options-any","text":"Joins an existing room by provided roomName and options . Locked or private rooms are ignored by this method. JavaScript client . join ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Join < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . join ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> join < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; });","title":"join (roomName: string, options: any)"},{"location":"client/client/#joinbyid-roomid-string-options-any","text":"Joins an existing room by its roomId . Private rooms can be joined by id. JavaScript client . joinById ( \"KRYAKzRo2\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinById < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_by_id ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinById ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinById < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); Tip Use getAvailableRooms() to retrieve a list of roomId 's available for joining.","title":"joinById (roomId: string, options: any)"},{"location":"client/client/#reconnect-roomid-string-sessionid-string","text":"Reconnects the client into a room he was previously connected with. Must be used along with allowReconnection() in the server-side. JavaScript let room = client . reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" ). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . Reconnect < YourStateClass >( \"wNHTX5qik\" , \"SkNaHTazQ\" ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" , function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . reconnect ( \"wNHTX5qik\" , \"SkNaHTazQ\" , YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client - > reconnect < YourStateClass > ( \"wNHTX5qik\" , \"SkNaHTazQ\", [=](std::string err, Room<State>* room ) { if ( err != \"\" ) { std : : cout << \"join error: \" << err << std ::endl; return; } std :: cout << \"joined successfully\" << std :: endl ; } );","title":"reconnect (roomId: string, sessionId: string)"},{"location":"client/client/#getavailablerooms-roomname-string","text":"List all available rooms to connect. Locked and private rooms won't be listed. roomName is optional. JavaScript client . getAvailableRooms ( \"battle\" ). then ( rooms => { rooms . forEach (( room ) => { console . log ( room . roomId ); console . log ( room . clients ); console . log ( room . maxClients ); console . log ( room . metadata ); }); }). catch ( e => { console . error ( e ); }); C# try { var rooms = await client . GetAvailableRooms ( \"battle\" ); for ( int i = 0 ; i < rooms . Length ; i ++) { Debug . Log ( rooms [ i ]. roomId ); Debug . Log ( rooms [ i ]. clients ); Debug . Log ( rooms [ i ]. maxClients ); Debug . Log ( rooms [ i ]. metadata ); } } catch ( ex ) { Debug . Log ( ex . Message ) } /** * Retrieving custom metadata */ [Serializable] class Metadata { public string mode ; public string name ; } [Serializable] class CustomRoomAvailable : RoomAvailable { public Metadata metadata ; } var rooms = await client . GetAvailableRooms < CustomRoomAvailable >( \"battle\" ); Debug . Log ( rooms [ 0 ]. metadata . mode ); lua client : get_available_rooms ( \"battle\" , function ( err , rooms ) if ( err ) then console . error ( err ); return end for i , rooms in pairs ( rooms ) do print ( rooms [ i ]. roomId ) print ( rooms [ i ]. clients ) print ( rooms [ i ]. maxClients ) print ( rooms [ i ]. metadata ) end end ); Haxe client . getAvailableRooms ( \"battle\" , function ( err , rooms ) { if ( err != null ) { trace ( err ); return ; } for ( room in rooms ) { trace ( room . roomId ); trace ( room . clients ); trace ( room . maxClients ); trace ( room . metadata ); } }); C++ client . getAvailableRooms ( \"battle\" , [ = ]( std :: string err , nlohmann :: json rooms ) { if ( err != \"\" ) { std :: cout << \"error: \" << err << std :: endl ; return ; } // rooms });","title":"getAvailableRooms (roomName?: string)"},{"location":"client/client/#consumeseatreservation-reservation","text":"Join a room by consuming a seat reservation. Advanced usage See Match-maker API to see how to retrieve the seat reservation data. JavaScript client . consumeSeatReservation ( reservation ). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . ConsumeSeatReservation < YourStateClass >( reservation ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : consume_seat_reservation ( reservation , function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . consumeSeatReservation ( reservation , YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> consumeSeatReservation < YourStateClass > ( reservation , [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; });","title":"consumeSeatReservation (reservation)"},{"location":"client/room/","text":"Room API (Client-side) \u00b6 Properties \u00b6 state: any \u00b6 The current room's state. This variable is always synched with the latest state from the server-side. To listen for updates on the whole state, see onStateChange event. sessionId: string \u00b6 Unique identifier for the player. This property matches the client.sessionId from the server-side. id: string \u00b6 The unique idenfitier of the room. You can share this id with other clients in order to allow them to connect directly to this room. // get `roomId` from the query string let roomId = location . href . match ( /roomId=([a-zA-Z0-9\\-_]+)/ )[ 1 ]; // joining a room by its id client . joinById ( roomId ). then ( room => { // ... }); name: string \u00b6 Name of the room handler. Ex: \"battle\" . Methods \u00b6 send (data) \u00b6 Send message to the room handler. JavaScript room . send ({ move : \"left\" }); C# await room . Send ( new { move = \"left\" }); lua room : send ({ move = \"left\" }) Haxe room . send ({ move : \"left\" }); Use Room#onMessage() from the server-side to read the message. leave () \u00b6 Disconnect from the room. JavaScript room . leave (); C# room . Leave (); lua room : leave () Haxe room . leave (); Tip Use Room#onLeave() to handle the disconnection from the server-side. removeAllListeners() \u00b6 Removes onMessage , onStateChange , onLeave and onError listeners. Also removes all .listen() calls if you're using Fossil Delta serializer.. Events \u00b6 onStateChange \u00b6 This event is triggered when the server updates its state. JavaScript room . onStateChange . once (( state ) => { console . log ( \"this is the first room state!\" , state ); }); room . onStateChange (( state ) => { console . log ( \"the room state has been updated:\" , state ); }); C# room . OnStateChange += ( state , isFirstState ) => { if ( isFirstState ) { Debug . Log ( \"this is the first room state!\" ); } Debug . Log ( \"the room state has been updated\" ); } lua room : on ( \"statechange\" , function ( state ) print ( \"new state:\" , state ) end ) Haxe room . onStateChange += function ( state ) { trace ( \"new state:\" + Std . string ( state )); }; C++ room . onStateChange = [ = ]( State >* state ) { std :: cout << \"new state\" << std :: endl ; // ... }; onMessage \u00b6 This event is triggered when the server sends a message directly to the client. JavaScript room . onMessage (( message ) => { console . log ( \"message received from server\" ); console . log ( message ); }); C# room . OnMessage += ( message ) => { Debug . Log ( \"message received from server\" ); Debug . Log ( message ); } /** * Handling schema-encoded messages: */ room . OnMessage += ( message ) => { if ( message is MyMessage ) { Debug . Log ( \"MyMessage type has been received\" ); Debug . Log ( message ); } else if ( message is AnotherMessage ) { // ... } } lua room : on ( \"message\" , function ( message ) print ( \"message received from server\" ) print ( message ) end ) Haxe room . onMessage += function ( message ) { trace ( \"message received from server\" ); trace ( Std . string ( message )); }; C++ room . onMessage = [ = ]( msgpack :: object message ) -> void { std :: cout << \"message received from server\" << std :: endl ; std :: cout << message << std :: endl ; }; Tip To send a message from the server directly to the clients you'll need to use either room.send() or room.broadcast() onLeave \u00b6 This event is triggered when the client leave the room. Possible codes: 1000 : Regular Socket Shutdown higher than 1000 : Abnormal Socket Shutdown ( more details ) JavaScript room . onLeave (( code ) => { console . log ( \"client left the room\" ); }); C# room . OnLeave += ( code ) => { Debug . Log ( \"client left the room\" ); } lua room : on ( \"leave\" , function () print ( \"client left the room\" ) end ) Haxe room . onLeave += function () { trace ( \"client left the room\" ); }; Haxe room . onLeave = [ =] ( ) - > void { std::cout << \"client left the room\" << std::endl; }; onError \u00b6 This event is triggered when some error occurs in the room handler. JavaScript room . onError (( message ) => { console . log ( \"oops, error ocurred:\" ); console . log ( message ); }); C# room . OnError += ( message ) => { Debug . Log ( \"oops, error ocurred:\" ); Debug . Log ( message ); } lua room : on ( \"error\" , function ( message ) print ( \"oops, error ocurred:\" ) print ( message ) end ) Haxe room . onError += function ( message ) { trace ( \"oops, error ocurred:\" ); trace ( message ); }; C++ room . onError = [ = ] ( std :: string message ) => void { std :: cout << \"oops, error ocurred: \" << message << std :: endl ; };","title":"Room"},{"location":"client/room/#room-api-client-side","text":"","title":"Room API (Client-side)"},{"location":"client/room/#properties","text":"","title":"Properties"},{"location":"client/room/#state-any","text":"The current room's state. This variable is always synched with the latest state from the server-side. To listen for updates on the whole state, see onStateChange event.","title":"state: any"},{"location":"client/room/#sessionid-string","text":"Unique identifier for the player. This property matches the client.sessionId from the server-side.","title":"sessionId: string"},{"location":"client/room/#id-string","text":"The unique idenfitier of the room. You can share this id with other clients in order to allow them to connect directly to this room. // get `roomId` from the query string let roomId = location . href . match ( /roomId=([a-zA-Z0-9\\-_]+)/ )[ 1 ]; // joining a room by its id client . joinById ( roomId ). then ( room => { // ... });","title":"id: string"},{"location":"client/room/#name-string","text":"Name of the room handler. Ex: \"battle\" .","title":"name: string"},{"location":"client/room/#methods","text":"","title":"Methods"},{"location":"client/room/#send-data","text":"Send message to the room handler. JavaScript room . send ({ move : \"left\" }); C# await room . Send ( new { move = \"left\" }); lua room : send ({ move = \"left\" }) Haxe room . send ({ move : \"left\" }); Use Room#onMessage() from the server-side to read the message.","title":"send (data)"},{"location":"client/room/#leave","text":"Disconnect from the room. JavaScript room . leave (); C# room . Leave (); lua room : leave () Haxe room . leave (); Tip Use Room#onLeave() to handle the disconnection from the server-side.","title":"leave ()"},{"location":"client/room/#removealllisteners","text":"Removes onMessage , onStateChange , onLeave and onError listeners. Also removes all .listen() calls if you're using Fossil Delta serializer..","title":"removeAllListeners()"},{"location":"client/room/#events","text":"","title":"Events"},{"location":"client/room/#onstatechange","text":"This event is triggered when the server updates its state. JavaScript room . onStateChange . once (( state ) => { console . log ( \"this is the first room state!\" , state ); }); room . onStateChange (( state ) => { console . log ( \"the room state has been updated:\" , state ); }); C# room . OnStateChange += ( state , isFirstState ) => { if ( isFirstState ) { Debug . Log ( \"this is the first room state!\" ); } Debug . Log ( \"the room state has been updated\" ); } lua room : on ( \"statechange\" , function ( state ) print ( \"new state:\" , state ) end ) Haxe room . onStateChange += function ( state ) { trace ( \"new state:\" + Std . string ( state )); }; C++ room . onStateChange = [ = ]( State >* state ) { std :: cout << \"new state\" << std :: endl ; // ... };","title":"onStateChange"},{"location":"client/room/#onmessage","text":"This event is triggered when the server sends a message directly to the client. JavaScript room . onMessage (( message ) => { console . log ( \"message received from server\" ); console . log ( message ); }); C# room . OnMessage += ( message ) => { Debug . Log ( \"message received from server\" ); Debug . Log ( message ); } /** * Handling schema-encoded messages: */ room . OnMessage += ( message ) => { if ( message is MyMessage ) { Debug . Log ( \"MyMessage type has been received\" ); Debug . Log ( message ); } else if ( message is AnotherMessage ) { // ... } } lua room : on ( \"message\" , function ( message ) print ( \"message received from server\" ) print ( message ) end ) Haxe room . onMessage += function ( message ) { trace ( \"message received from server\" ); trace ( Std . string ( message )); }; C++ room . onMessage = [ = ]( msgpack :: object message ) -> void { std :: cout << \"message received from server\" << std :: endl ; std :: cout << message << std :: endl ; }; Tip To send a message from the server directly to the clients you'll need to use either room.send() or room.broadcast()","title":"onMessage"},{"location":"client/room/#onleave","text":"This event is triggered when the client leave the room. Possible codes: 1000 : Regular Socket Shutdown higher than 1000 : Abnormal Socket Shutdown ( more details ) JavaScript room . onLeave (( code ) => { console . log ( \"client left the room\" ); }); C# room . OnLeave += ( code ) => { Debug . Log ( \"client left the room\" ); } lua room : on ( \"leave\" , function () print ( \"client left the room\" ) end ) Haxe room . onLeave += function () { trace ( \"client left the room\" ); }; Haxe room . onLeave = [ =] ( ) - > void { std::cout << \"client left the room\" << std::endl; };","title":"onLeave"},{"location":"client/room/#onerror","text":"This event is triggered when some error occurs in the room handler. JavaScript room . onError (( message ) => { console . log ( \"oops, error ocurred:\" ); console . log ( message ); }); C# room . OnError += ( message ) => { Debug . Log ( \"oops, error ocurred:\" ); Debug . Log ( message ); } lua room : on ( \"error\" , function ( message ) print ( \"oops, error ocurred:\" ) print ( message ) end ) Haxe room . onError += function ( message ) { trace ( \"oops, error ocurred:\" ); trace ( message ); }; C++ room . onError = [ = ] ( std :: string message ) => void { std :: cout << \"oops, error ocurred: \" << message << std :: endl ; };","title":"onError"},{"location":"getting-started/cocos2dx-client/","text":"Installation \u00b6 Download Cocos2d-X and follow their installation instructions . Download colyseus-cocos2d-x and copy the Source/ files into your project. Add the Source/ directory to your project's Header Search Paths . Usage \u00b6 Below you can see how to use the Client , matchmake into a Room , and send and receive messages from the connected room. See how to generate your RoomState from State Handling #include \"Colyseus/Client.h\"; Client * client = new Client ( \"ws://localhost:2567\" ); Room * room ; bool HelloWorld :: init () { client = new Client ( \"ws://localhost:2667\" ); client -> joinOrCreate < RoomState > ( \"state_handler\" , {}, [ = ]( std :: string err , Room < RoomState >* _room ) { if ( err != \"\" ) { std :: cout << \"JOIN ERROR! \" << err << std :: endl ; return ; } room = _room ; room -> onMessage = [ = ] ( msgpack :: object message ) -> void { std :: cout << message << std :: endl ; } room -> onStateChange = [ = ] ( RoomState * state ) -> void { // ... }; room -> onError = [ this ]( std :: string message ) -> void { std :: cout << \"ROOM ERROR => \" << message . c_str () << std :: endl ; }; room -> onLeave = [ this ]() -> void { std :: cout << \"LEFT ROOM\" << std :: endl ; }; room -> getState () -> players -> onAdd = [ this ]( Player * player , string sessionId ) -> void { // add player sprite auto sprite = Sprite :: create ( \"HelloWorld.png\" ); sprite -> setPosition ( player -> x , player -> y ); players . insert ( sessionId , sprite ); this -> addChild ( sprite , 0 ); player -> onChange = [ this , sprite , player ]( std :: vector < colyseus :: schema :: DataChange > changes ) -> void { for ( int i = 0 ; i < changes . size (); i ++ ) { if ( changes [ i ]. field == \"x\" ) { sprite -> setPositionX ( player -> x ); } else if ( changes [ i ]. field == \"y\" ) { sprite -> setPositionY ( player -> y ); } } }; }; room -> getState () -> players -> onRemove = [ this ]( Player * player , string sessionId ) -> void { std :: cout << \"onRemove called!\" << std :: endl ; auto sprite = players . at ( sessionId ); this -> removeChild ( sprite ); players . erase ( sessionId ); std :: cout << \"onRemove complete!\" << std :: endl ; }; std :: cout << \"Done!\" << std :: endl ; }); } Example \u00b6 The example is using colyseus-examples as a server ( 02-state-handler.ts example). Please follow installation instructions from colyseus-examples 's README. Running the client \u00b6 From the Example directory, run the cocos run -p {platform-id} command, e.g.: Building for Windows: cocos run -p win32 Building for Mac: cocos run -p mac","title":"Cocos2dx client"},{"location":"getting-started/cocos2dx-client/#installation","text":"Download Cocos2d-X and follow their installation instructions . Download colyseus-cocos2d-x and copy the Source/ files into your project. Add the Source/ directory to your project's Header Search Paths .","title":"Installation"},{"location":"getting-started/cocos2dx-client/#usage","text":"Below you can see how to use the Client , matchmake into a Room , and send and receive messages from the connected room. See how to generate your RoomState from State Handling #include \"Colyseus/Client.h\"; Client * client = new Client ( \"ws://localhost:2567\" ); Room * room ; bool HelloWorld :: init () { client = new Client ( \"ws://localhost:2667\" ); client -> joinOrCreate < RoomState > ( \"state_handler\" , {}, [ = ]( std :: string err , Room < RoomState >* _room ) { if ( err != \"\" ) { std :: cout << \"JOIN ERROR! \" << err << std :: endl ; return ; } room = _room ; room -> onMessage = [ = ] ( msgpack :: object message ) -> void { std :: cout << message << std :: endl ; } room -> onStateChange = [ = ] ( RoomState * state ) -> void { // ... }; room -> onError = [ this ]( std :: string message ) -> void { std :: cout << \"ROOM ERROR => \" << message . c_str () << std :: endl ; }; room -> onLeave = [ this ]() -> void { std :: cout << \"LEFT ROOM\" << std :: endl ; }; room -> getState () -> players -> onAdd = [ this ]( Player * player , string sessionId ) -> void { // add player sprite auto sprite = Sprite :: create ( \"HelloWorld.png\" ); sprite -> setPosition ( player -> x , player -> y ); players . insert ( sessionId , sprite ); this -> addChild ( sprite , 0 ); player -> onChange = [ this , sprite , player ]( std :: vector < colyseus :: schema :: DataChange > changes ) -> void { for ( int i = 0 ; i < changes . size (); i ++ ) { if ( changes [ i ]. field == \"x\" ) { sprite -> setPositionX ( player -> x ); } else if ( changes [ i ]. field == \"y\" ) { sprite -> setPositionY ( player -> y ); } } }; }; room -> getState () -> players -> onRemove = [ this ]( Player * player , string sessionId ) -> void { std :: cout << \"onRemove called!\" << std :: endl ; auto sprite = players . at ( sessionId ); this -> removeChild ( sprite ); players . erase ( sessionId ); std :: cout << \"onRemove complete!\" << std :: endl ; }; std :: cout << \"Done!\" << std :: endl ; }); }","title":"Usage"},{"location":"getting-started/cocos2dx-client/#example","text":"The example is using colyseus-examples as a server ( 02-state-handler.ts example). Please follow installation instructions from colyseus-examples 's README.","title":"Example"},{"location":"getting-started/cocos2dx-client/#running-the-client","text":"From the Example directory, run the cocos run -p {platform-id} command, e.g.: Building for Windows: cocos run -p win32 Building for Mac: cocos run -p mac","title":"Running the client"},{"location":"getting-started/construct3-client/","text":"Construct 3 (compatible with C3 and C2 runtime from Construct3) Construct 2 See Multiplayer Drawing Prototype made with this plugin. ( live demo ) Important \u00b6 Construct has well-known existing features to \"host\" a multiplayer session from the client. This is not possible via Colyseus. Colyseus is an authoritative SERVER, written in Node.js. You can't make your client be the host of the game sessions. Handling messages \u00b6 An important note when sending messages from the server to the clients: you need to provide an object with a \"type\" field, in order for the client to be able to parse it. Server-side this . broadcast ({ type : \"foo\" , data : \"bar\" }); Client-side Use the On Message condition, with \"foo\" as argument. Properties \u00b6 Default Endpoint \u00b6 Default Endpoint to use on \"Connect\" action. Actions \u00b6 Set endpoint to {0} \u00b6 Format: wss://example.com Join room {0} with options {1}. \u00b6 Join a room by name Join room {0} with options {1}. \u00b6 Join a room by name Create room {0} with options {1}. \u00b6 Create a room by name Join room {0} with options {1}. \u00b6 Join an existing room by its ID Reconnect into room {0} with sessionId {1}. \u00b6 Reconnect using a previously connected room Send {0} with {1} \u00b6 Send message to a room Leave from the room \u00b6 Disconnect client from the room. Conditions \u00b6 On Join \u00b6 Triggered when joined successfully into a room. On Leave \u00b6 Triggered when left from a room. On Error \u00b6 Triggered when an error happened on the server. On Message ({0}) \u00b6 Triggered when the room broadcasts a message, or sends a message directly to this client. On State Change \u00b6 Triggered when the state of the room changes. On add at {0} \u00b6 Triggers when an item is added to ArraySchema or MapSchema. On field change at {0} \u00b6 Triggers when a field is changed inside a Schema instance. Need to use On change at {0} \u00b6 Triggers when an item is changed inside ArraySchema or MapSchema. On remove at {0} \u00b6 Triggers when an item is removed from ArraySchema or MapSchema. Is index {0} \u00b6 Only available for Arrays and Maps. Check if index of current item is equals to provided value. Is field {0} \u00b6 Only available during \"On change\" of a direct object. Checks if a field name has changed. Expressions \u00b6 JSON \u00b6 Declare a JSON value. CurrentValue \u00b6 Get value from current item PreviousValue \u00b6 Get previous value from current field. Only available during \"On change\" on an instance variable. Not avaialble for arrays and maps. CurrentValueAt \u00b6 Get nested value from current item CurrentIndex \u00b6 Get index of current item. Available during \"On Add\", \"On Change\" or \"On Remove\" CurrentField \u00b6 Get current field being changed. Available during \"On field change\" State \u00b6 Get a value from room's state SessionId \u00b6 Unique sessionId of the current user","title":"Construct3 client"},{"location":"getting-started/construct3-client/#important","text":"Construct has well-known existing features to \"host\" a multiplayer session from the client. This is not possible via Colyseus. Colyseus is an authoritative SERVER, written in Node.js. You can't make your client be the host of the game sessions.","title":"Important"},{"location":"getting-started/construct3-client/#handling-messages","text":"An important note when sending messages from the server to the clients: you need to provide an object with a \"type\" field, in order for the client to be able to parse it. Server-side this . broadcast ({ type : \"foo\" , data : \"bar\" }); Client-side Use the On Message condition, with \"foo\" as argument.","title":"Handling messages"},{"location":"getting-started/construct3-client/#properties","text":"","title":"Properties"},{"location":"getting-started/construct3-client/#default-endpoint","text":"Default Endpoint to use on \"Connect\" action.","title":"Default Endpoint"},{"location":"getting-started/construct3-client/#actions","text":"","title":"Actions"},{"location":"getting-started/construct3-client/#set-endpoint-to-0","text":"Format: wss://example.com","title":"Set endpoint to {0}"},{"location":"getting-started/construct3-client/#join-room-0-with-options-1","text":"Join a room by name","title":"Join room {0} with options {1}."},{"location":"getting-started/construct3-client/#join-room-0-with-options-1_1","text":"Join a room by name","title":"Join room {0} with options {1}."},{"location":"getting-started/construct3-client/#create-room-0-with-options-1","text":"Create a room by name","title":"Create room {0} with options {1}."},{"location":"getting-started/construct3-client/#join-room-0-with-options-1_2","text":"Join an existing room by its ID","title":"Join room {0} with options {1}."},{"location":"getting-started/construct3-client/#reconnect-into-room-0-with-sessionid-1","text":"Reconnect using a previously connected room","title":"Reconnect into room {0} with sessionId {1}."},{"location":"getting-started/construct3-client/#send-0-with-1","text":"Send message to a room","title":"Send {0} with {1}"},{"location":"getting-started/construct3-client/#leave-from-the-room","text":"Disconnect client from the room.","title":"Leave from the room"},{"location":"getting-started/construct3-client/#conditions","text":"","title":"Conditions"},{"location":"getting-started/construct3-client/#on-join","text":"Triggered when joined successfully into a room.","title":"On Join"},{"location":"getting-started/construct3-client/#on-leave","text":"Triggered when left from a room.","title":"On Leave"},{"location":"getting-started/construct3-client/#on-error","text":"Triggered when an error happened on the server.","title":"On Error"},{"location":"getting-started/construct3-client/#on-message-0","text":"Triggered when the room broadcasts a message, or sends a message directly to this client.","title":"On Message ({0})"},{"location":"getting-started/construct3-client/#on-state-change","text":"Triggered when the state of the room changes.","title":"On State Change"},{"location":"getting-started/construct3-client/#on-add-at-0","text":"Triggers when an item is added to ArraySchema or MapSchema.","title":"On add at {0}"},{"location":"getting-started/construct3-client/#on-field-change-at-0","text":"Triggers when a field is changed inside a Schema instance. Need to use","title":"On field change at {0}"},{"location":"getting-started/construct3-client/#on-change-at-0","text":"Triggers when an item is changed inside ArraySchema or MapSchema.","title":"On change at {0}"},{"location":"getting-started/construct3-client/#on-remove-at-0","text":"Triggers when an item is removed from ArraySchema or MapSchema.","title":"On remove at {0}"},{"location":"getting-started/construct3-client/#is-index-0","text":"Only available for Arrays and Maps. Check if index of current item is equals to provided value.","title":"Is index {0}"},{"location":"getting-started/construct3-client/#is-field-0","text":"Only available during \"On change\" of a direct object. Checks if a field name has changed.","title":"Is field {0}"},{"location":"getting-started/construct3-client/#expressions","text":"","title":"Expressions"},{"location":"getting-started/construct3-client/#json","text":"Declare a JSON value.","title":"JSON"},{"location":"getting-started/construct3-client/#currentvalue","text":"Get value from current item","title":"CurrentValue"},{"location":"getting-started/construct3-client/#previousvalue","text":"Get previous value from current field. Only available during \"On change\" on an instance variable. Not avaialble for arrays and maps.","title":"PreviousValue"},{"location":"getting-started/construct3-client/#currentvalueat","text":"Get nested value from current item","title":"CurrentValueAt"},{"location":"getting-started/construct3-client/#currentindex","text":"Get index of current item. Available during \"On Add\", \"On Change\" or \"On Remove\"","title":"CurrentIndex"},{"location":"getting-started/construct3-client/#currentfield","text":"Get current field being changed. Available during \"On field change\"","title":"CurrentField"},{"location":"getting-started/construct3-client/#state","text":"Get a value from room's state","title":"State"},{"location":"getting-started/construct3-client/#sessionid","text":"Unique sessionId of the current user","title":"SessionId"},{"location":"getting-started/defold-client/","text":"Defold Client \u00b6 Defold Engine is a Free 2D Game Engine for Cross-Platform Publishing. The colyseus-defold client has been tested on all major platforms supported by Defold, such as HTML5, iOS, Android, Mac and Windows. Installation \u00b6 You will need to add colyseus-defold , as well as its dependencies into your game.project dependencies section in order to use the client. Open your game.project file, and add the following URLs to the Dependencies section (under Project -> Dependencies ): https://github.com/colyseus/colyseus-defold/archive/master.zip https://github.com/britzl/defold-websocket/archive/master.zip https://github.com/britzl/defold-luasocket/archive/0.11.zip https://github.com/britzl/defold-luasec/archive/master.zip Read more about Defold library dependencies You can also specify a specific release of the client, by copying its respective zip archive URL. Usage \u00b6 local ColyseusClient = require \"colyseus.client\" local client local room function init ( self ) -- Add initialization code here client = ColyseusClient . new ( \"ws://localhost:2567\" ) -- join chat room client : join_or_create ( \"chat\" , {}, function ( err , _room ) if err then print ( \"JOIN ERROR: \" .. err ) return end room = _room end ) end function update ( self , dt ) client : loop () end See client-side documentation . Example \u00b6 Check out the tic-tac-toe example made by @selimanac FAQ \u00b6 \"I can't connect to the local server!\" \u00b6 When running on localhost, make sure you don't have any service running on port 80, otherwise the client won't connect into the specified port number. Alternatively, you can bind the Colyseus server to port 80. \" reconnect() is not working on iOS!\" \u00b6 If you lock your phone, all WebSocket connections will be closed. You can call reconnect() to reestablish the session, which needs a workaround for iOS: function window_callback ( self , event , data ) if event == window . WINDOW_EVENT_FOCUS_GAINED then -- iOS workaround to re-active WebSocket connection after phone is unlocked room : send ({ \"whatever\" }) end end window . set_listener ( window_callback ) Dependencies \u00b6 The colyseus-defold depends on the WebSocket, LuaSocket and LuaSec projects: defold-websocket defold-luasocket defold-luasec","title":"Defold Client"},{"location":"getting-started/defold-client/#defold-client","text":"Defold Engine is a Free 2D Game Engine for Cross-Platform Publishing. The colyseus-defold client has been tested on all major platforms supported by Defold, such as HTML5, iOS, Android, Mac and Windows.","title":"Defold Client"},{"location":"getting-started/defold-client/#installation","text":"You will need to add colyseus-defold , as well as its dependencies into your game.project dependencies section in order to use the client. Open your game.project file, and add the following URLs to the Dependencies section (under Project -> Dependencies ): https://github.com/colyseus/colyseus-defold/archive/master.zip https://github.com/britzl/defold-websocket/archive/master.zip https://github.com/britzl/defold-luasocket/archive/0.11.zip https://github.com/britzl/defold-luasec/archive/master.zip Read more about Defold library dependencies You can also specify a specific release of the client, by copying its respective zip archive URL.","title":"Installation"},{"location":"getting-started/defold-client/#usage","text":"local ColyseusClient = require \"colyseus.client\" local client local room function init ( self ) -- Add initialization code here client = ColyseusClient . new ( \"ws://localhost:2567\" ) -- join chat room client : join_or_create ( \"chat\" , {}, function ( err , _room ) if err then print ( \"JOIN ERROR: \" .. err ) return end room = _room end ) end function update ( self , dt ) client : loop () end See client-side documentation .","title":"Usage"},{"location":"getting-started/defold-client/#example","text":"Check out the tic-tac-toe example made by @selimanac","title":"Example"},{"location":"getting-started/defold-client/#faq","text":"","title":"FAQ"},{"location":"getting-started/defold-client/#i-cant-connect-to-the-local-server","text":"When running on localhost, make sure you don't have any service running on port 80, otherwise the client won't connect into the specified port number. Alternatively, you can bind the Colyseus server to port 80.","title":"\"I can't connect to the local server!\""},{"location":"getting-started/defold-client/#reconnect-is-not-working-on-ios","text":"If you lock your phone, all WebSocket connections will be closed. You can call reconnect() to reestablish the session, which needs a workaround for iOS: function window_callback ( self , event , data ) if event == window . WINDOW_EVENT_FOCUS_GAINED then -- iOS workaround to re-active WebSocket connection after phone is unlocked room : send ({ \"whatever\" }) end end window . set_listener ( window_callback )","title":"\"reconnect() is not working on iOS!\""},{"location":"getting-started/defold-client/#dependencies","text":"The colyseus-defold depends on the WebSocket, LuaSocket and LuaSec projects: defold-websocket defold-luasocket defold-luasec","title":"Dependencies"},{"location":"getting-started/haxe-client/","text":"You're encouraged to use this client along with any Haxe Game Engine, such as: OpenFL , Kha , HaxeFlixel , Heaps , HaxePunk , etc. Installation \u00b6 Install colyseus from haxelib: haxelib install colyseus Usage \u00b6 Connecting to server: \u00b6 import io . colyseus . Client ; import io . colyseus . Room ; var client = new Client ( 'ws://localhost:2567' ); Joining to a room: \u00b6 See how to generate your RoomState from State Handling client . joinOrCreate ( \"room_name\" , [], RoomState , function ( err , room ) { if ( err != null ) { trace ( \"JOIN ERROR: \" + err ); return ; } room . state . entities . onAdd = function ( entity , key ) { trace ( \"entity added at \" + key + \" => \" + entity ); entity . onChange = function ( changes ) { trace ( \"entity changes => \" + changes ); } } room . state . entities . onChange = function ( entity , key ) { trace ( \"entity changed at \" + key + \" => \" + entity ); } room . state . entities . onRemove = function ( entity , key ) { trace ( \"entity removed at \" + key + \" => \" + entity ); } }); Other room events \u00b6 Room state has been updated: room . onStateChange += function ( state ) { // full new state avaialble on 'state' variable } Message broadcasted from server or directly to this client: room . onMessage += function ( message ) { trace ( client . id + \" received on \" + room . name + \": \" + message ); } Server error occurred: room . onError += function () { trace ( client . id + \" couldn't join \" + room . name ); } The client left the room: room . onLeave += function () { trace ( client . id + \" left \" + room . name ); } Running the demo project \u00b6 The example project can be compiled to html5 , neko , cpp , ios , etc. It uses the state_handler room from the colyseus-examples project, which you can find here . Compiling the demo project to html5 \u00b6 git clone https://github.com/colyseus/colyseus-hx.git cd colyseus-hx/example/openfl lime build project.xml html5 You can see the demo project live here . ios target caveats \u00b6 You may need to manually apply this patch in order to compile for iOS: HaxeFoundation/hxcpp@5f63d23 More info: http://community.openfl.org/t/solved-system-not-available-on-ios-with-xcode-9-0/9683?source_topic_id=10046","title":"Haxe client"},{"location":"getting-started/haxe-client/#installation","text":"Install colyseus from haxelib: haxelib install colyseus","title":"Installation"},{"location":"getting-started/haxe-client/#usage","text":"","title":"Usage"},{"location":"getting-started/haxe-client/#connecting-to-server","text":"import io . colyseus . Client ; import io . colyseus . Room ; var client = new Client ( 'ws://localhost:2567' );","title":"Connecting to server:"},{"location":"getting-started/haxe-client/#joining-to-a-room","text":"See how to generate your RoomState from State Handling client . joinOrCreate ( \"room_name\" , [], RoomState , function ( err , room ) { if ( err != null ) { trace ( \"JOIN ERROR: \" + err ); return ; } room . state . entities . onAdd = function ( entity , key ) { trace ( \"entity added at \" + key + \" => \" + entity ); entity . onChange = function ( changes ) { trace ( \"entity changes => \" + changes ); } } room . state . entities . onChange = function ( entity , key ) { trace ( \"entity changed at \" + key + \" => \" + entity ); } room . state . entities . onRemove = function ( entity , key ) { trace ( \"entity removed at \" + key + \" => \" + entity ); } });","title":"Joining to a room:"},{"location":"getting-started/haxe-client/#other-room-events","text":"Room state has been updated: room . onStateChange += function ( state ) { // full new state avaialble on 'state' variable } Message broadcasted from server or directly to this client: room . onMessage += function ( message ) { trace ( client . id + \" received on \" + room . name + \": \" + message ); } Server error occurred: room . onError += function () { trace ( client . id + \" couldn't join \" + room . name ); } The client left the room: room . onLeave += function () { trace ( client . id + \" left \" + room . name ); }","title":"Other room events"},{"location":"getting-started/haxe-client/#running-the-demo-project","text":"The example project can be compiled to html5 , neko , cpp , ios , etc. It uses the state_handler room from the colyseus-examples project, which you can find here .","title":"Running the demo project"},{"location":"getting-started/haxe-client/#compiling-the-demo-project-to-html5","text":"git clone https://github.com/colyseus/colyseus-hx.git cd colyseus-hx/example/openfl lime build project.xml html5 You can see the demo project live here .","title":"Compiling the demo project to html5"},{"location":"getting-started/haxe-client/#ios-target-caveats","text":"You may need to manually apply this patch in order to compile for iOS: HaxeFoundation/hxcpp@5f63d23 More info: http://community.openfl.org/t/solved-system-not-available-on-ios-with-xcode-9-0/9683?source_topic_id=10046","title":"ios target caveats"},{"location":"getting-started/javascript-client/","text":"JavaScript\u5ba2\u6237\u7aef \u00b6 \u5e73\u53f0\u517c\u5bb9\u6027 \u00b6 JavaScript\u5ba2\u6237\u7aef\u517c\u5bb9\uff1a \u4e3b\u8981\u6d4f\u89c8\u5668\u73af\u5883 ( Electron , Chrome, Firefox, Safari, Opera, etc) React Native ( with some caveats ) Cocos Creator ( instructions ) NodeJS \u4e0d\u77e5\u9053\u5982\u4f55\u4f7f\u7528NodeJS webpack \u7684\u6784\u5efa\u7cfb\u7edf? \u53ea\u9700\u5c06 JavaScript distribution file \u4fdd\u5b58\u5e76\u62d6\u653e\u5230\u60a8\u7684\u9879\u76ee\u4e2d\uff0c\u7136\u540e\u5ffd\u7565 import \u6587\u6863\u4e2d\u6b64\u5904\u663e\u793a\u7684\u8bed\u53e5\u3002 \u4f7f\u7528 \u00b6 \u5b89\u88c5\u6a21\u5757 \u00b6 npm install --save colyseus.js \u8fde\u63a5\u5230\u670d\u52a1\u5668\uff1a \u00b6 import * as Colyseus from \"colyseus.js\" ; var client = new Colyseus . Client ( 'ws://localhost:2567' ); \u52a0\u5165\u623f\u95f4\uff1a \u00b6 client . join ( \"room_name\" ). then ( room => { console . log ( room . sessionId , \"joined\" , room . name ); }). catch ( e => { console . log ( \"JOIN ERROR\" , e ); }); \u623f\u95f4\u4e8b\u4ef6 \u00b6 \u623f\u95f4\u72b6\u6001\u5df2\u66f4\u65b0\uff1a room . onStateChange (( state ) => { console . log ( room . name , \"has new state:\" , state ); }); \u4ece\u670d\u52a1\u5668\u5e7f\u64ad\u6216\u76f4\u63a5\u5e7f\u64ad\u5230\u6b64\u5ba2\u6237\u7aef\u7684\u6d88\u606f\uff1a room . onMessage (( message ) => { console . log ( client . id , \"received on\" , room . name , message ); }); \u53d1\u751f\u670d\u52a1\u5668\u9519\u8bef\uff1a room . onError (() => { console . log ( client . id , \"couldn't join\" , room . name ); }); \u5ba2\u6237\u79bb\u5f00\u623f\u95f4\uff1a room . onLeave (() => { console . log ( client . id , \"left\" , room . name ); }); React Native \u517c\u5bb9\u6027 \u00b6 \u8be5\u5ba2\u6237\u7aef\u4e0eReact Native\u4e00\u8d77\u4f7f\u7528\u3002\u60a8\u9700\u8981\u5b89\u88c5\u4e00\u4e9b\u5176\u4ed6\u4f9d\u8d56\u9879\u4ee5\u5b9e\u73b0\u517c\u5bb9\u6027\u5e76\u5c06\u5176\u5206\u914d window.localStorage \u7ed9 AsyncStorage \u3002 npm install buffer // App.js import { AsyncStorage } from 'react-native' ; import { Buffer } from \"buffer\" ; window . localStorage = AsyncStorage ; global . Buffer = Buffer ; Cocos Creator \u6307\u5f15 \u00b6 \u4eceGithub\u4e0b\u8f7d\u6700\u65b0\u65b0\u7684\u6784\u5efa\u6587\u4ef6 colyseus.js \u3002 \u5c06\u5176\u4fdd\u5b58\u5230\u9879\u76ee\u7684 scripts \u6587\u4ef6\u5939\u4e2d\u3002 \u5bfc\u5165\u4f7f\u7528 const Colyseus = require('colyseus.js')","title":"JavaScript \u5ba2\u6237\u7aef"},{"location":"getting-started/javascript-client/#javascript","text":"","title":"JavaScript\u5ba2\u6237\u7aef"},{"location":"getting-started/javascript-client/#_1","text":"JavaScript\u5ba2\u6237\u7aef\u517c\u5bb9\uff1a \u4e3b\u8981\u6d4f\u89c8\u5668\u73af\u5883 ( Electron , Chrome, Firefox, Safari, Opera, etc) React Native ( with some caveats ) Cocos Creator ( instructions ) NodeJS \u4e0d\u77e5\u9053\u5982\u4f55\u4f7f\u7528NodeJS webpack \u7684\u6784\u5efa\u7cfb\u7edf? \u53ea\u9700\u5c06 JavaScript distribution file \u4fdd\u5b58\u5e76\u62d6\u653e\u5230\u60a8\u7684\u9879\u76ee\u4e2d\uff0c\u7136\u540e\u5ffd\u7565 import \u6587\u6863\u4e2d\u6b64\u5904\u663e\u793a\u7684\u8bed\u53e5\u3002","title":"\u5e73\u53f0\u517c\u5bb9\u6027"},{"location":"getting-started/javascript-client/#_2","text":"","title":"\u4f7f\u7528"},{"location":"getting-started/javascript-client/#_3","text":"npm install --save colyseus.js","title":"\u5b89\u88c5\u6a21\u5757"},{"location":"getting-started/javascript-client/#_4","text":"import * as Colyseus from \"colyseus.js\" ; var client = new Colyseus . Client ( 'ws://localhost:2567' );","title":"\u8fde\u63a5\u5230\u670d\u52a1\u5668\uff1a"},{"location":"getting-started/javascript-client/#_5","text":"client . join ( \"room_name\" ). then ( room => { console . log ( room . sessionId , \"joined\" , room . name ); }). catch ( e => { console . log ( \"JOIN ERROR\" , e ); });","title":"\u52a0\u5165\u623f\u95f4\uff1a"},{"location":"getting-started/javascript-client/#_6","text":"\u623f\u95f4\u72b6\u6001\u5df2\u66f4\u65b0\uff1a room . onStateChange (( state ) => { console . log ( room . name , \"has new state:\" , state ); }); \u4ece\u670d\u52a1\u5668\u5e7f\u64ad\u6216\u76f4\u63a5\u5e7f\u64ad\u5230\u6b64\u5ba2\u6237\u7aef\u7684\u6d88\u606f\uff1a room . onMessage (( message ) => { console . log ( client . id , \"received on\" , room . name , message ); }); \u53d1\u751f\u670d\u52a1\u5668\u9519\u8bef\uff1a room . onError (() => { console . log ( client . id , \"couldn't join\" , room . name ); }); \u5ba2\u6237\u79bb\u5f00\u623f\u95f4\uff1a room . onLeave (() => { console . log ( client . id , \"left\" , room . name ); });","title":"\u623f\u95f4\u4e8b\u4ef6"},{"location":"getting-started/javascript-client/#react-native","text":"\u8be5\u5ba2\u6237\u7aef\u4e0eReact Native\u4e00\u8d77\u4f7f\u7528\u3002\u60a8\u9700\u8981\u5b89\u88c5\u4e00\u4e9b\u5176\u4ed6\u4f9d\u8d56\u9879\u4ee5\u5b9e\u73b0\u517c\u5bb9\u6027\u5e76\u5c06\u5176\u5206\u914d window.localStorage \u7ed9 AsyncStorage \u3002 npm install buffer // App.js import { AsyncStorage } from 'react-native' ; import { Buffer } from \"buffer\" ; window . localStorage = AsyncStorage ; global . Buffer = Buffer ;","title":"React Native \u517c\u5bb9\u6027"},{"location":"getting-started/javascript-client/#cocos-creator","text":"\u4eceGithub\u4e0b\u8f7d\u6700\u65b0\u65b0\u7684\u6784\u5efa\u6587\u4ef6 colyseus.js \u3002 \u5c06\u5176\u4fdd\u5b58\u5230\u9879\u76ee\u7684 scripts \u6587\u4ef6\u5939\u4e2d\u3002 \u5bfc\u5165\u4f7f\u7528 const Colyseus = require('colyseus.js')","title":"Cocos Creator \u6307\u5f15"},{"location":"getting-started/server/","text":"\u5165\u95e8 \u00b6 Colyseus\u9700\u8981 Node.js v8.0 \u6216\u66f4\u9ad8\u7248\u672c\u3002 \u4ece\u5b9e\u4f8b\u9879\u76ee\u5f00\u59cb \u00b6 \u901a\u8fc7\u514b\u9686 \u793a\u4f8b\u9879\u76ee \u5e76\u5728\u672c\u5730\u8fd0\u884c\uff0c\u53ef\u4ee5\u67e5\u770b\u4e00\u4e9b\u5b9e\u9645\u7684\u793a\u4f8b\u3002 git clone https://github.com/colyseus/colyseus-examples.git cd colyseus-examples npm install \u8981\u8fd0\u884chttp + websocket\u670d\u52a1\u5668\uff0c\u8bf7\u8fd0\u884c npm start \u3002 \u521b\u5efa\u4e00\u4e2a\u6807\u51c6\u7684Colyseus\u670d\u52a1\u5668 \u00b6 \u4f7f\u7528 npm init colyseus-app \u547d\u4ee4\u751f\u6210\u51c6\u7cfb\u7edfColyseus\u670d\u52a1\u5668\u3002\u60a8\u53ef\u4ee5\u9009\u62e9TypeScript\uff08\u63a8\u8350\uff09\uff0cJavaScript\u548cHaxe\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u9009\u62e9\u8bed\u8a00\u3002 npm init colyseus-app ./my-colyseus-app \u8bf7\u53c2\u9605\u9879\u76ee\u6a21\u677f\u7684\u5185\u5bb9\uff1a TypeScript JavaScript \u63a8\u8350\u7684NodeJS\u6e38\u620f\u5305 \u00b6 \u5728NodeJS\u548c\u6d4f\u89c8\u5668\u4e0a\u5f00\u53d1\u6e38\u620f\u65f6\uff0c\u8fd9\u4e9b\u6a21\u5757\u5f88\u6709\u7528\u3002 @gamestdio/mathf - \u4eceUnity3D\u7684API\u501f\u7528\u7684\u6570\u5b66\u51fd\u6570 @gamestdio/timer - \u53ef\u9760\u7684\u8ba1\u65f6\u4e8b\u4ef6 @gamestdio/keycode - \u952e\u76d8\u6309\u952e\u4ee3\u7801\u7684\u5e38\u91cf ( event.which ) \u8fd9\u4e9b\u6a21\u5757\u53ea\u80fd\u5728\u6d4f\u89c8\u5668\u4e2d\u4f7f\u7528\uff1a @gamestdio/pixi-engine","title":"\u670d\u52a1\u5668\u6bb5"},{"location":"getting-started/server/#_1","text":"Colyseus\u9700\u8981 Node.js v8.0 \u6216\u66f4\u9ad8\u7248\u672c\u3002","title":"\u5165\u95e8"},{"location":"getting-started/server/#_2","text":"\u901a\u8fc7\u514b\u9686 \u793a\u4f8b\u9879\u76ee \u5e76\u5728\u672c\u5730\u8fd0\u884c\uff0c\u53ef\u4ee5\u67e5\u770b\u4e00\u4e9b\u5b9e\u9645\u7684\u793a\u4f8b\u3002 git clone https://github.com/colyseus/colyseus-examples.git cd colyseus-examples npm install \u8981\u8fd0\u884chttp + websocket\u670d\u52a1\u5668\uff0c\u8bf7\u8fd0\u884c npm start \u3002","title":"\u4ece\u5b9e\u4f8b\u9879\u76ee\u5f00\u59cb"},{"location":"getting-started/server/#colyseus","text":"\u4f7f\u7528 npm init colyseus-app \u547d\u4ee4\u751f\u6210\u51c6\u7cfb\u7edfColyseus\u670d\u52a1\u5668\u3002\u60a8\u53ef\u4ee5\u9009\u62e9TypeScript\uff08\u63a8\u8350\uff09\uff0cJavaScript\u548cHaxe\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u9009\u62e9\u8bed\u8a00\u3002 npm init colyseus-app ./my-colyseus-app \u8bf7\u53c2\u9605\u9879\u76ee\u6a21\u677f\u7684\u5185\u5bb9\uff1a TypeScript JavaScript","title":"\u521b\u5efa\u4e00\u4e2a\u6807\u51c6\u7684Colyseus\u670d\u52a1\u5668"},{"location":"getting-started/server/#nodejs","text":"\u5728NodeJS\u548c\u6d4f\u89c8\u5668\u4e0a\u5f00\u53d1\u6e38\u620f\u65f6\uff0c\u8fd9\u4e9b\u6a21\u5757\u5f88\u6709\u7528\u3002 @gamestdio/mathf - \u4eceUnity3D\u7684API\u501f\u7528\u7684\u6570\u5b66\u51fd\u6570 @gamestdio/timer - \u53ef\u9760\u7684\u8ba1\u65f6\u4e8b\u4ef6 @gamestdio/keycode - \u952e\u76d8\u6309\u952e\u4ee3\u7801\u7684\u5e38\u91cf ( event.which ) \u8fd9\u4e9b\u6a21\u5757\u53ea\u80fd\u5728\u6d4f\u89c8\u5668\u4e2d\u4f7f\u7528\uff1a @gamestdio/pixi-engine","title":"\u63a8\u8350\u7684NodeJS\u6e38\u620f\u5305"},{"location":"getting-started/unity3d-client/","text":"Installation \u00b6 Download the latest version of colyseus-unity3d locally. ( download link ) Copy Assets/Plugins files into your Unity project. Running the demo server \u00b6 The colyseus-unity3d comes with a usage example , and a simple room handler for basic testing. You can test it locally by running these commands in your commandline: cd Server npm install npm start The demo server is using @colyseus/social for user authentication. Please download and install MongoDB locally: https://docs.mongodb.com/manual/installation/#mongodb-community-edition-installation-tutorials Tip Ensure you have Node v8+ installed locally to run the server. Usage \u00b6 Each Client and Room connections need to run on its own Coroutine. See usage example for more details. Connecting to the Server \u00b6 Client client = new Colyseus . Client ( \"ws://localhost:2567\" ); Joining a Room \u00b6 See how to generate your RoomState from State Handling try { Room room = await client . Join < RoomState > ( \"room_name\" ); Debug . Log ( \"Joined successfully!\" ); } catch ( ex ) { Debug . Log ( \"Error joining: \" + ex . Message ); } Getting the full room state from the server. \u00b6 room . OnStateChange += OnStateChange ; void OnStateChange ( State state , bool isFirstState ) { if ( isFirstState ) { // First setup of your client state Debug . Log ( state ); } else { // Further updates on your client state Debug . Log ( state ); } } Attaching callbacks to your schema structures \u00b6 See how to generate your RoomState from State Handling Room room = await client . Join < RoomState > ( \"room_name\" ); Debug . Log ( \"Joined room successfully.\" ); room . State . players . OnAdd += OnPlayerAdd ; room . State . players . OnRemove += OnPlayerRemove ; room . State . players . OnChange += OnPlayerChange ; void OnPlayerAdd ( Player player , string key ) { Debug . Log ( \"player added!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key } void OnPlayerRemove ( Player player , string key ) { Debug . Log ( \"player removed!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key } void OnPlayerChange ( Player player , string key ) { Debug . Log ( \"player moved!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key } Debugging \u00b6 If you set a breakpoint in your application while the WebSocket connection is open, the connection will be closed automatically after 3 seconds due to inactivity. To prevent the WebSocket connection from dropping, use pingInterval: 0 during development: import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... pingInterval : 0 // HERE }); Make sure to have a pingInterval higher than 0 on production. The default pingInterval value is 1500 .","title":"Unity3d \u5ba2\u6237\u7aef"},{"location":"getting-started/unity3d-client/#installation","text":"Download the latest version of colyseus-unity3d locally. ( download link ) Copy Assets/Plugins files into your Unity project.","title":"Installation"},{"location":"getting-started/unity3d-client/#running-the-demo-server","text":"The colyseus-unity3d comes with a usage example , and a simple room handler for basic testing. You can test it locally by running these commands in your commandline: cd Server npm install npm start The demo server is using @colyseus/social for user authentication. Please download and install MongoDB locally: https://docs.mongodb.com/manual/installation/#mongodb-community-edition-installation-tutorials Tip Ensure you have Node v8+ installed locally to run the server.","title":"Running the demo server"},{"location":"getting-started/unity3d-client/#usage","text":"Each Client and Room connections need to run on its own Coroutine. See usage example for more details.","title":"Usage"},{"location":"getting-started/unity3d-client/#connecting-to-the-server","text":"Client client = new Colyseus . Client ( \"ws://localhost:2567\" );","title":"Connecting to the Server"},{"location":"getting-started/unity3d-client/#joining-a-room","text":"See how to generate your RoomState from State Handling try { Room room = await client . Join < RoomState > ( \"room_name\" ); Debug . Log ( \"Joined successfully!\" ); } catch ( ex ) { Debug . Log ( \"Error joining: \" + ex . Message ); }","title":"Joining a Room"},{"location":"getting-started/unity3d-client/#getting-the-full-room-state-from-the-server","text":"room . OnStateChange += OnStateChange ; void OnStateChange ( State state , bool isFirstState ) { if ( isFirstState ) { // First setup of your client state Debug . Log ( state ); } else { // Further updates on your client state Debug . Log ( state ); } }","title":"Getting the full room state from the server."},{"location":"getting-started/unity3d-client/#attaching-callbacks-to-your-schema-structures","text":"See how to generate your RoomState from State Handling Room room = await client . Join < RoomState > ( \"room_name\" ); Debug . Log ( \"Joined room successfully.\" ); room . State . players . OnAdd += OnPlayerAdd ; room . State . players . OnRemove += OnPlayerRemove ; room . State . players . OnChange += OnPlayerChange ; void OnPlayerAdd ( Player player , string key ) { Debug . Log ( \"player added!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key } void OnPlayerRemove ( Player player , string key ) { Debug . Log ( \"player removed!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key } void OnPlayerChange ( Player player , string key ) { Debug . Log ( \"player moved!\" ); Debug . Log ( player ); // Here's your `Player` instance Debug . Log ( key ); // Here's your `Player` key }","title":"Attaching callbacks to your schema structures"},{"location":"getting-started/unity3d-client/#debugging","text":"If you set a breakpoint in your application while the WebSocket connection is open, the connection will be closed automatically after 3 seconds due to inactivity. To prevent the WebSocket connection from dropping, use pingInterval: 0 during development: import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... pingInterval : 0 // HERE }); Make sure to have a pingInterval higher than 0 on production. The default pingInterval value is 1500 .","title":"Debugging"},{"location":"how-to/deny-player-join-a-room/","text":"\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728 onAuth() \u6216 onJoin() \u65b9\u6cd5\u671f\u95f4\u629b\u51fa\u9519\u8bef\u6765\u62d2\u7edd\u73a9\u5bb6\u8fde\u63a5\u3002 \u4f55\u65f6\u62d2\u7edd\u73a9\u5bb6\u8fde\u63a5\u7684\u5b9e\u73b0\u53d6\u51b3\u4e8e\u60a8\u7684\u7528\u4f8b\u3002 \u5728\u4e0b\u9762\uff0c\u60a8\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u793a\u4f8b\uff0c\u8be5\u793a\u4f8b\u9a8c\u8bc1 @colyseus/social \u8eab\u4efd\u9a8c\u8bc1\u4ee4\u724c\uff0c\u5e76\u68c0\u7d22 Hero \u4e0e\u7528\u6237ID\u94fe\u63a5\u7684\u8bb0\u5f55\u3002 export class BattleRoom extends Room { onCreate ( options ) { this . levelRequired = 10 ; } async onAuth ( client , options ) { const userId = verifyToken ( options . token ). _id ; const hero = await Hero . findOne ({ userId }); if ( ! hero ) { throw new Error ( \"'Hero' not found in the database!\" ); } else if ( hero . level < this . levelRequired ) { throw new Error ( \"player do not have the level required to be on this room.\" ); } return hero ; } } \u5c1d\u8bd5\u52a0\u5165\u623f\u95f4\u65f6\uff0c\u5ba2\u6237\u7aef\u5c06\u6536\u5230\u9519\u8bef\u6d88\u606f\uff1a client . joinOrCreate ( \"battle\" , {}). then ( room => { // ... }). catch ( e => { console . log ( e ) // \"'Hero' not found in the database!\" })","title":"\u62d2\u7edd\u73a9\u5bb6\u52a0\u5165\u623f\u95f4"},{"location":"how-to/password-protect-room/","text":"\u6b65\u9aa41\uff1a \u5141\u8bb8 matchmaker \u8bc6\u522b\u5230 \"password\" \u5b57\u6bb5. \u00b6 \u5728 filterBy() \u65b9\u6cd5\u5185\u90e8\u5b9a\u4e49\u5b57\u6bb5 \"password\" \u3002 gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'password' ]) \u6b65\u9aa42\uff1a\u5c06\u623f\u95f4\u8bbe\u4e3a\u4e0d\u516c\u5f00 \u00b6 \u5982\u679c\u4e3a create() \u6216\u8005 joinOrCreate() \u8bbe\u7f6e\u4e86\u5bc6\u7801, \u8bf7\u5c06\u623f\u95f4\u5c5e\u6027\u8bbe\u7f6e\u4e3a\u79c1\u6709\u7684: export class BattleRoom extends Room { onCreate ( options ) { if ( options . password ) { this . setPrivate (); } } }","title":"\u7528\u5bc6\u7801\u4fdd\u62a4\u623f\u95f4"},{"location":"how-to/password-protect-room/#1-matchmaker-password","text":"\u5728 filterBy() \u65b9\u6cd5\u5185\u90e8\u5b9a\u4e49\u5b57\u6bb5 \"password\" \u3002 gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'password' ])","title":"\u6b65\u9aa41\uff1a \u5141\u8bb8 matchmaker \u8bc6\u522b\u5230 \"password\" \u5b57\u6bb5."},{"location":"how-to/password-protect-room/#2","text":"\u5982\u679c\u4e3a create() \u6216\u8005 joinOrCreate() \u8bbe\u7f6e\u4e86\u5bc6\u7801, \u8bf7\u5c06\u623f\u95f4\u5c5e\u6027\u8bbe\u7f6e\u4e3a\u79c1\u6709\u7684: export class BattleRoom extends Room { onCreate ( options ) { if ( options . password ) { this . setPrivate (); } } }","title":"\u6b65\u9aa42\uff1a\u5c06\u623f\u95f4\u8bbe\u4e3a\u4e0d\u516c\u5f00"},{"location":"how-to/rate-limit/","text":"\u60a8\u6700\u7ec8\u53ef\u80fd\u4f1a\u53d1\u73b0\u6076\u610f\u7528\u6237\u5229\u7528Colyseus\u7684\u7275\u7ebf\u642d\u6865\u5145\u65a5\u60a8\u7684\u670d\u52a1\u5668\u623f\u95f4\uff0c\u5bfc\u81f4\u60a8\u7684\u670d\u52a1\u5668\u521b\u5efa\u548c\u5220\u9664\u623f\u95f4\u800c\u6ca1\u6709\u5b9e\u9645\u4f7f\u7528\u73a9\u5bb6\u3002 \u5efa\u8bae\u4f7f\u7528 express-rate-limit \u4e2d\u95f4\u4ef6\u963b\u6b62\u6765\u81ea\u540c\u4e00\u6e90\u7684\u592a\u591a\u8bf7\u6c42\u3002\u5728 express-rate-limit 's README \u4e2d\u67e5\u770b\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff1b npm install --save express-rate-limit \u4f7f\u7528 \u00b6 TypeScript import rateLimit from \"express-rate-limit\" ; const apiLimiter = rateLimit ({ windowMs : 15 * 60 * 1000 , // 15 minutes max : 100 }); app . use ( \"/matchmake/\" , apiLimiter ); JavaScript const rateLimit = require ( \"express-rate-limit\" ); const apiLimiter = rateLimit ({ windowMs : 15 * 60 * 1000 , // 15 minutes max : 100 }); app . use ( \"/matchmake/\" , apiLimiter ); \u5982\u679c\u4f60\u4f7f\u7528\u4e86\u53cd\u5411\u4ee3\u7406 (\u4f8b\u5982) Heroku, Bluemix, AWS ELB, Nginx, etc)\uff0c\u8fd8\u9700\u8981\u542f\u7528 \"trust proxy\" // see https://expressjs.com/en/guide/behind-proxies.html app . set ( 'trust proxy' , 1 );","title":"\u9650\u901f"},{"location":"how-to/rate-limit/#_1","text":"TypeScript import rateLimit from \"express-rate-limit\" ; const apiLimiter = rateLimit ({ windowMs : 15 * 60 * 1000 , // 15 minutes max : 100 }); app . use ( \"/matchmake/\" , apiLimiter ); JavaScript const rateLimit = require ( \"express-rate-limit\" ); const apiLimiter = rateLimit ({ windowMs : 15 * 60 * 1000 , // 15 minutes max : 100 }); app . use ( \"/matchmake/\" , apiLimiter ); \u5982\u679c\u4f60\u4f7f\u7528\u4e86\u53cd\u5411\u4ee3\u7406 (\u4f8b\u5982) Heroku, Bluemix, AWS ELB, Nginx, etc)\uff0c\u8fd8\u9700\u8981\u542f\u7528 \"trust proxy\" // see https://expressjs.com/en/guide/behind-proxies.html app . set ( 'trust proxy' , 1 );","title":"\u4f7f\u7528"},{"location":"migrating/","text":"Migrating between Colyseus versions \u00b6 This page has been moved. Check the version you'd like to migrate on \"Migrating\" in the sidebar.","title":"Migrating between Colyseus versions"},{"location":"migrating/#migrating-between-colyseus-versions","text":"This page has been moved. Check the version you'd like to migrate on \"Migrating\" in the sidebar.","title":"Migrating between Colyseus versions"},{"location":"migrating/0.10/","text":"Migrating to version 0.10.x (from 0.9.x) \u00b6 Server-side \u00b6 EntityMap<T> has been removed. If you're using EntityMap<T> to describe a map of entities, you should use the plain TypeScript alternative now. e.g. Replace \" EntityMap<Player> \" with \" {[id: string]: Player} \", or migrate to the new serializer. New default serializer \u00b6 Colyseus 0.10 has introduced a new serialization method ( SchemaSerializer ). Even though it's recommened to use the new serializer, you can continue using the previous one ( FossilDeltaSerializer ). I want to continue using the previous serializer \u00b6 No problem, check below how to continue using the previous serializer using TypeScript or plain JavaScript. TypeScript import { Room , FossilDeltaSerializer , serialize } from \"colyseus\" ; @ serialize ( FossilDeltaSerializer ) class MyRoom extends Room { // your room definition } JavaScript const colyseus = require ( 'colyseus' ); class MyRoom extends colyseus . Room { // your room definition } colyseus . serialize ( colyseus . FossilDeltaSerializer )( MyRoom ); I want to migrate to the new serializer \u00b6 Great, hopefully you won't have to make many changes in your project. In the client-side, the way to listen for state patches has changed slightly. See how to use the new SchemaSerializer in the server-side . See how to listen for changes in the state using SchemaSerializer . Client-side \u00b6 colyseus-unity3d \u00b6 It's highly recommended to migrate to the new schema serializer. See how to generate the schema in the client-side based on the definitions from the server. client.id has been renamed to client.Id room.id has been renamed to room.Id room.name has been renamed to room.Name room.sessionId has been renamed to room.SessionId room.state has been renamed to room.State e.message has been renamed to e.Message (on MessageEventArgs and ErrorEventArgs ) Room<T> needs to provide the generic type for state holder when using Fossil Delta, it's Room<IndexedDictionary<string, object>> when using Schema it's Room<YourStateClass> RoomUpdateEventArgs has been renamed to StateChangeEventArgs<T> T is IndexedDictionary<string, object> when using Fossil Delta T is YourStateClass when using Schema. e.state has been renamed to e.State","title":"0.10.x"},{"location":"migrating/0.10/#migrating-to-version-010x-from-09x","text":"","title":"Migrating to version 0.10.x (from 0.9.x)"},{"location":"migrating/0.10/#server-side","text":"EntityMap<T> has been removed. If you're using EntityMap<T> to describe a map of entities, you should use the plain TypeScript alternative now. e.g. Replace \" EntityMap<Player> \" with \" {[id: string]: Player} \", or migrate to the new serializer.","title":"Server-side"},{"location":"migrating/0.10/#new-default-serializer","text":"Colyseus 0.10 has introduced a new serialization method ( SchemaSerializer ). Even though it's recommened to use the new serializer, you can continue using the previous one ( FossilDeltaSerializer ).","title":"New default serializer"},{"location":"migrating/0.10/#i-want-to-continue-using-the-previous-serializer","text":"No problem, check below how to continue using the previous serializer using TypeScript or plain JavaScript. TypeScript import { Room , FossilDeltaSerializer , serialize } from \"colyseus\" ; @ serialize ( FossilDeltaSerializer ) class MyRoom extends Room { // your room definition } JavaScript const colyseus = require ( 'colyseus' ); class MyRoom extends colyseus . Room { // your room definition } colyseus . serialize ( colyseus . FossilDeltaSerializer )( MyRoom );","title":"I want to continue using the previous serializer"},{"location":"migrating/0.10/#i-want-to-migrate-to-the-new-serializer","text":"Great, hopefully you won't have to make many changes in your project. In the client-side, the way to listen for state patches has changed slightly. See how to use the new SchemaSerializer in the server-side . See how to listen for changes in the state using SchemaSerializer .","title":"I want to migrate to the new serializer"},{"location":"migrating/0.10/#client-side","text":"","title":"Client-side"},{"location":"migrating/0.10/#colyseus-unity3d","text":"It's highly recommended to migrate to the new schema serializer. See how to generate the schema in the client-side based on the definitions from the server. client.id has been renamed to client.Id room.id has been renamed to room.Id room.name has been renamed to room.Name room.sessionId has been renamed to room.SessionId room.state has been renamed to room.State e.message has been renamed to e.Message (on MessageEventArgs and ErrorEventArgs ) Room<T> needs to provide the generic type for state holder when using Fossil Delta, it's Room<IndexedDictionary<string, object>> when using Schema it's Room<YourStateClass> RoomUpdateEventArgs has been renamed to StateChangeEventArgs<T> T is IndexedDictionary<string, object> when using Fossil Delta T is YourStateClass when using Schema. e.state has been renamed to e.State","title":"colyseus-unity3d"},{"location":"migrating/0.11/","text":"Migrating to version 0.11.x (from 0.10.x) \u00b6 The version 0.11 improves match-making and scalability, and introduces breaking changes in both client-side and server-side. Client-side \u00b6 client.id has been removed! \u00b6 If you're using client.id in the client-side, you should replace it with room.sessionId . New match-making methods available in the client-side! \u00b6 A few methods have been added to the client-side allowing to explicitly create rooms or join them. joinOrCreate(roomName, options) - joins or creates a room by name (previously known as join() ) create(roomName, options) - only creates new rooms join(roomName, options) - only joins existing rooms by name joinById(roomId, options) - only joins existing rooms by id reconnect(roomId, sessionId) - re-establish a previously lost connection (previously known as rejoin() ) Also, the Room instance is not returned immediatelly in the client-side. A promise is returned instead, and it is fulfilled whenever the onJoin() has finished successfully. Replace your existing client.join() calls with its new client.joinOrCreate() : JavaScript client . joinOrCreate ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinOrCreate < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_or_create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinOrCreate ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinOrCreate < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); Lua, Haxe and C++ In languages that doesn't provide an async mechanism out of the box, a callback is expected as last argument for the matchmaking functions. The callback gets invoked whenever the onJoin() has been finished successfully. room.onJoin is not necessary anymore in the client-side \u00b6 The room.onJoin is now only used internally. When the promise (or callback) fulfils returning the room instance, it has already been joined successfully. The reconnect() now expects the room id instead of room name. \u00b6 Previously, the rejoin() method accepted the room name and sessionId. Now, with reconnect() you should pass the room id instead of the room name: client . reconnect ( roomId , sessionId ). then ( room => { /* ... */ }); JavaScript/TypeScript: Signals API has changed slighly \u00b6 The room signals are onLeave , onStateChange , onMessage and onError . Use onStateChange(callback) instead of onStateChange.add(callback) Use onStateChange.once(callback) instead of onStateChange.addOnce(callback) C#/Unity \u00b6 The sender object has been removed from all Schema callbacks and events. Schema callbacks API has changed slighly \u00b6 Use players.OnAdd += (Player player, string key) => {} . Use players.OnRemove += (Player player, string key) => {} . ... and so on! Events API has changed slighly \u00b6 The events are onLeave , onStateChange , onMessage and onError . No need to use client.Connect() , room.ReadyToConnect() , room.Connect() , or client.Recv() anymore. Use onStateChange += (State state, bool isFirstState) => {} instead of onStateChange += (sender, e) => {} Use onMessage += (object message) => {} instead of onMessage += (sender, e) => {} Use onLeave += (int code) => {} instead of onLeave += (sender, e) => {} Use onError += (string message) => {} instead of onError += (sender, e) => {} arraySchema.GetItems() now returns a Dictionary<int, MySchemaType> instead of a List<MySchemaType> . Replace any cases of (List<MySchemaType>) state.myArraySchema.GetItems() with ((Dictionary<int, MySchemaType>) state.myArraySchema.GetItems()).Values.ToList() . Server-side \u00b6 Usage with express \u00b6 Before creating the Colyseus.Server instance, you'll need to: use the express.json() middleware use the cors() middleware ( if you're testing server/client from different port or domain ) pass both server and express to the Colyseus.Server constructor. TypeScript import http from \"http\" ; import express from \"express\" ; import cors from \"cors\" ; import { Server } from \"colyseus\" ; const app = express (); app . use ( cors ()); app . use ( express . json ()); const server = http . createServer ( app ); const gameServer = new Server ({ server : server }); JavaScript const http = require ( \"http\" ); const express = require ( \"express\" ); const cors = require ( \"cors\" ); const colyseus = require ( \"colyseus\" ); const app = express (); app . use ( cors ()); app . use ( express . json ()); const server = http . createServer ( app ); const gameServer = new colyseus . Server ({ server : server }); gameServer.register has been renamed to gameServer.define \u00b6 onInit(options) has been renamed to onCreate(options) \u00b6 Replace your onInit(options) method in your room with onCreate(options) . onAuth(options) is now onAuth(client, options) \u00b6 Replace your onAuth(options) method in your room with onAuth(client, options) . client.id is now an alias to client.sessionId \u00b6 As the client.id has been removed from the client-side, it is now just an alias to client.sessionId (available in the client-side as room.sessionId ). The client.id was not a reliable source to identify unique users. If you need an efficient way to determine if the user is the same in multiple browser tabs, consider using some form of authentication. The anonymous authentication from @colyseus/social can serve this purpose very well. The requestJoin() method has been deprecated. \u00b6 Instead of using requestJoin() to determine wheter a player is allowed to join a room, you should use matchmaking filters for your defined rooms. Take this example of using requestJoin() from version 0.10 , and how to translate it to 0.11 : // version 0.10 class MyRoom extends Room { onInit ( options ) { this . progress = options . progress ; } requestJoin ( options , isNew ) { return this . progress === options . progress ; } } You can have the same behaviour by defining a progress filter when defining your room. The requestJoin() method should be removed. // version 0.11 gameServer . define ( \"dungeon\" , DungeonRoom ) . filterBy ([ 'progress' ]); Avoid using this.clients inside onJoin() or onAuth() \u00b6 The client instance will be automatically added to the this.clients list only after onJoin() has been completed. If you have a piece of code like this: onJoin ( client , options ) { if ( this . clients . length === 2 ) { // do something! } } It's encouraged to replace with something else, like this: onJoin ( client , options ) { this . state . players [ client . sessionId ] = new Player ( /*...*/ ); if ( Object . keys ( this . state . players ). length === 2 ) { // do something! } } onLeave ( client , options ) { delete this . state . players [ client . sessionId ]; }","title":"0.11.x"},{"location":"migrating/0.11/#migrating-to-version-011x-from-010x","text":"The version 0.11 improves match-making and scalability, and introduces breaking changes in both client-side and server-side.","title":"Migrating to version 0.11.x (from 0.10.x)"},{"location":"migrating/0.11/#client-side","text":"","title":"Client-side"},{"location":"migrating/0.11/#clientid-has-been-removed","text":"If you're using client.id in the client-side, you should replace it with room.sessionId .","title":"client.id has been removed!"},{"location":"migrating/0.11/#new-match-making-methods-available-in-the-client-side","text":"A few methods have been added to the client-side allowing to explicitly create rooms or join them. joinOrCreate(roomName, options) - joins or creates a room by name (previously known as join() ) create(roomName, options) - only creates new rooms join(roomName, options) - only joins existing rooms by name joinById(roomId, options) - only joins existing rooms by id reconnect(roomId, sessionId) - re-establish a previously lost connection (previously known as rejoin() ) Also, the Room instance is not returned immediatelly in the client-side. A promise is returned instead, and it is fulfilled whenever the onJoin() has finished successfully. Replace your existing client.join() calls with its new client.joinOrCreate() : JavaScript client . joinOrCreate ( \"battle\" , { /* options */ }). then ( room => { console . log ( \"joined successfully\" , room ); }). catch ( e => { console . error ( \"join error\" , e ); }); C# try { Room < YourStateClass > room = await client . JoinOrCreate < YourStateClass >( \"battle\" , /* Dictionary of options */ ); Debug . Log ( \"joined successfully\" ); } catch ( ex ) { Debug . Log ( \"join error\" ); Debug . Log ( ex . Message ); } lua client : join_or_create ( \"battle\" , { --[[options]] }, function ( err , room ) if ( err ~= nil ) then print ( \"join error: \" .. err ) return end print ( \"joined successfully\" ) end ) Haxe client . joinOrCreate ( \"battle\" , [ /* options */ ], YourStateClass , function ( err , room ) { if ( err != null ) { trace ( \"join error: \" + err ); return ; } trace ( \"joined successfully\" ); }); C++ client -> joinOrCreate < YourStateClass > ( \"battle\" , { /* options */ }, [ = ]( std :: string err , Room < State >* room ) { if ( err != \"\" ) { std :: cout << \"join error: \" << err << std :: endl ; return ; } std :: cout << \"joined successfully\" << std :: endl ; }); Lua, Haxe and C++ In languages that doesn't provide an async mechanism out of the box, a callback is expected as last argument for the matchmaking functions. The callback gets invoked whenever the onJoin() has been finished successfully.","title":"New match-making methods available in the client-side!"},{"location":"migrating/0.11/#roomonjoin-is-not-necessary-anymore-in-the-client-side","text":"The room.onJoin is now only used internally. When the promise (or callback) fulfils returning the room instance, it has already been joined successfully.","title":"room.onJoin is not necessary anymore in the client-side"},{"location":"migrating/0.11/#the-reconnect-now-expects-the-room-id-instead-of-room-name","text":"Previously, the rejoin() method accepted the room name and sessionId. Now, with reconnect() you should pass the room id instead of the room name: client . reconnect ( roomId , sessionId ). then ( room => { /* ... */ });","title":"The reconnect() now expects the room id instead of room name."},{"location":"migrating/0.11/#javascripttypescript-signals-api-has-changed-slighly","text":"The room signals are onLeave , onStateChange , onMessage and onError . Use onStateChange(callback) instead of onStateChange.add(callback) Use onStateChange.once(callback) instead of onStateChange.addOnce(callback)","title":"JavaScript/TypeScript: Signals API has changed slighly"},{"location":"migrating/0.11/#cunity","text":"The sender object has been removed from all Schema callbacks and events.","title":"C#/Unity"},{"location":"migrating/0.11/#schema-callbacks-api-has-changed-slighly","text":"Use players.OnAdd += (Player player, string key) => {} . Use players.OnRemove += (Player player, string key) => {} . ... and so on!","title":"Schema callbacks API has changed slighly"},{"location":"migrating/0.11/#events-api-has-changed-slighly","text":"The events are onLeave , onStateChange , onMessage and onError . No need to use client.Connect() , room.ReadyToConnect() , room.Connect() , or client.Recv() anymore. Use onStateChange += (State state, bool isFirstState) => {} instead of onStateChange += (sender, e) => {} Use onMessage += (object message) => {} instead of onMessage += (sender, e) => {} Use onLeave += (int code) => {} instead of onLeave += (sender, e) => {} Use onError += (string message) => {} instead of onError += (sender, e) => {} arraySchema.GetItems() now returns a Dictionary<int, MySchemaType> instead of a List<MySchemaType> . Replace any cases of (List<MySchemaType>) state.myArraySchema.GetItems() with ((Dictionary<int, MySchemaType>) state.myArraySchema.GetItems()).Values.ToList() .","title":"Events API has changed slighly"},{"location":"migrating/0.11/#server-side","text":"","title":"Server-side"},{"location":"migrating/0.11/#usage-with-express","text":"Before creating the Colyseus.Server instance, you'll need to: use the express.json() middleware use the cors() middleware ( if you're testing server/client from different port or domain ) pass both server and express to the Colyseus.Server constructor. TypeScript import http from \"http\" ; import express from \"express\" ; import cors from \"cors\" ; import { Server } from \"colyseus\" ; const app = express (); app . use ( cors ()); app . use ( express . json ()); const server = http . createServer ( app ); const gameServer = new Server ({ server : server }); JavaScript const http = require ( \"http\" ); const express = require ( \"express\" ); const cors = require ( \"cors\" ); const colyseus = require ( \"colyseus\" ); const app = express (); app . use ( cors ()); app . use ( express . json ()); const server = http . createServer ( app ); const gameServer = new colyseus . Server ({ server : server });","title":"Usage with express"},{"location":"migrating/0.11/#gameserverregister-has-been-renamed-to-gameserverdefine","text":"","title":"gameServer.register has been renamed to gameServer.define"},{"location":"migrating/0.11/#oninitoptions-has-been-renamed-to-oncreateoptions","text":"Replace your onInit(options) method in your room with onCreate(options) .","title":"onInit(options) has been renamed to onCreate(options)"},{"location":"migrating/0.11/#onauthoptions-is-now-onauthclient-options","text":"Replace your onAuth(options) method in your room with onAuth(client, options) .","title":"onAuth(options) is now onAuth(client, options)"},{"location":"migrating/0.11/#clientid-is-now-an-alias-to-clientsessionid","text":"As the client.id has been removed from the client-side, it is now just an alias to client.sessionId (available in the client-side as room.sessionId ). The client.id was not a reliable source to identify unique users. If you need an efficient way to determine if the user is the same in multiple browser tabs, consider using some form of authentication. The anonymous authentication from @colyseus/social can serve this purpose very well.","title":"client.id is now an alias to client.sessionId"},{"location":"migrating/0.11/#the-requestjoin-method-has-been-deprecated","text":"Instead of using requestJoin() to determine wheter a player is allowed to join a room, you should use matchmaking filters for your defined rooms. Take this example of using requestJoin() from version 0.10 , and how to translate it to 0.11 : // version 0.10 class MyRoom extends Room { onInit ( options ) { this . progress = options . progress ; } requestJoin ( options , isNew ) { return this . progress === options . progress ; } } You can have the same behaviour by defining a progress filter when defining your room. The requestJoin() method should be removed. // version 0.11 gameServer . define ( \"dungeon\" , DungeonRoom ) . filterBy ([ 'progress' ]);","title":"The requestJoin() method has been deprecated."},{"location":"migrating/0.11/#avoid-using-thisclients-inside-onjoin-or-onauth","text":"The client instance will be automatically added to the this.clients list only after onJoin() has been completed. If you have a piece of code like this: onJoin ( client , options ) { if ( this . clients . length === 2 ) { // do something! } } It's encouraged to replace with something else, like this: onJoin ( client , options ) { this . state . players [ client . sessionId ] = new Player ( /*...*/ ); if ( Object . keys ( this . state . players ). length === 2 ) { // do something! } } onLeave ( client , options ) { delete this . state . players [ client . sessionId ]; }","title":"Avoid using this.clients inside onJoin() or onAuth()"},{"location":"migrating/0.12/","text":"Migrating to version 0.12.x (from 0.11.x) \u00b6 Version 0.12.x has mostly internal improvements and bug fixes. Please install the latest version of the server, as well as the client: Upgrading the server: npm install colyseus@^0.12.0 --save Upgrading the client: npm install colyseus.js@^0.12.0 --save If you're using Unity or other client, please check on its respective repository on GitHub. If you have questions feel free to ask on Discord Using this.broadcast() during onJoin() in the server \u00b6 The version 0.11.x introduced a bug where this.broadcast() would not send the message to the current connecting client during onJoin() ( #260 ). Forcing you to also use this.send(client, ...) in order for the connecting client to also receive that message. This has been fixed now on 0.12.x : class MyRoom extends Room { onJoin ( client , options ) { this . broadcast ( /* your data */ ); /** * IF YOU'RE ALSO USING `this.send()` HERE, YOU CAN SAFELY REMOVE IT, * OTHERWISE THE MESSAGE WILL ARIVE TWICE FOR THIS CLIENT */ // this.send(client, /* your data */); } } The @serialize() decorator has been deprecated. \u00b6 The @serialize decorator was introduced on version 0.10 , and it's now deprecated. You can remove the @serialize() call from your project, as the serializer is now determined automatically whenever you use this.setState() . The Fossil Delta serializer is still supported on 0.12, and will probably continue to exist for JavaScript, LUA and C# clients. Other clients won't ever support the Fossil Delta serializer.","title":"0.12.x"},{"location":"migrating/0.12/#migrating-to-version-012x-from-011x","text":"Version 0.12.x has mostly internal improvements and bug fixes. Please install the latest version of the server, as well as the client: Upgrading the server: npm install colyseus@^0.12.0 --save Upgrading the client: npm install colyseus.js@^0.12.0 --save If you're using Unity or other client, please check on its respective repository on GitHub. If you have questions feel free to ask on Discord","title":"Migrating to version 0.12.x (from 0.11.x)"},{"location":"migrating/0.12/#using-thisbroadcast-during-onjoin-in-the-server","text":"The version 0.11.x introduced a bug where this.broadcast() would not send the message to the current connecting client during onJoin() ( #260 ). Forcing you to also use this.send(client, ...) in order for the connecting client to also receive that message. This has been fixed now on 0.12.x : class MyRoom extends Room { onJoin ( client , options ) { this . broadcast ( /* your data */ ); /** * IF YOU'RE ALSO USING `this.send()` HERE, YOU CAN SAFELY REMOVE IT, * OTHERWISE THE MESSAGE WILL ARIVE TWICE FOR THIS CLIENT */ // this.send(client, /* your data */); } }","title":"Using this.broadcast() during onJoin() in the server"},{"location":"migrating/0.12/#the-serialize-decorator-has-been-deprecated","text":"The @serialize decorator was introduced on version 0.10 , and it's now deprecated. You can remove the @serialize() call from your project, as the serializer is now determined automatically whenever you use this.setState() . The Fossil Delta serializer is still supported on 0.12, and will probably continue to exist for JavaScript, LUA and C# clients. Other clients won't ever support the Fossil Delta serializer.","title":"The @serialize() decorator has been deprecated."},{"location":"migrating/0.9/","text":"Migrating to version 0.9.x (from 0.6.x or 0.8.x) \u00b6 Server-side \u00b6 ClusterServer has been deprecated. Use Server instead. Room#verifyClient(client, options) has been renamed to Room#onAuth(options) Integration with uws module has changed. See how to integrate here . Client-side \u00b6 colyseus.js \u00b6 room.onData has been renamed to room.onMessage . room.onUpdate has been renamed to room.onStateChange room.data has been renamed to room.state colyseus-unity3d \u00b6 room.OnData has been renamed to room.OnMessage . room.OnUpdate has been renamed to room.OnStateChange room.data has been renamed to room.state Migrating to 0.5.x (from 0.4.x) \u00b6 Use Server#listen to bind http port. \u00b6 The Server is now using the ClusterServer under the hood, which will spawn workers automatically. If you're using the Server instead of ClusterServer directly, you should call its listen method. OLD import { createServer } from 'http'; import { Server } from 'colyseus'; const httpServer = createServer(app); const gameServer = new Server({ server: httpServer }); httpServer.listen(2567); NEW import { createServer } from 'http'; import { Server } from 'colyseus'; const httpServer = createServer(app); const gameServer = new Server({ server: httpServer }); gameServer.listen(2567); // calling 'listen' from gameServer instead of httpServer constructor signature changed. use onCreate instead. \u00b6 OLD constructor (options) { super(options); // ... initialize the room } NEW constructor () { // room has been constructed. no options available yet! } onCreate (options) { // ... initialize the room } requestJoin - can return type can be either boolean or number ( 0..1 ) \u00b6 OLD requestJoin (options) { // accept connections if this room is not full. return this.clients.length < 10; } NEW requestJoin (options) { // give priority to connect on rooms with fewer clients. return 1 - (this.clients.length) / 10; } use patchRate property instead of setPatchRate() method. \u00b6 OLD constructor (options) { this.setPatchRate(1000 / 50); } NEW class MyRoom extends Room { patchRate = 1000 / 50; } client.id / client.sessionId \u00b6 client.sessionId - is a unique identifier of a user connected in a room. client.id - is a unique identifier of a user. if the user connects to the same room twice, you can identify he has two sessions by checking for client.id . If you don't bother having the same user connected multiple times in a room, always use client.sessionId to identify it. new room.maxClients property. \u00b6 OLD - if you're just checking for client.length on requestJoin , you probably can switch to maxClients instead. requestJoin (options) { return this.clients.length < 10; } NEW class MyRoom extends Room { maxClients = 10; } Migrating to 0.4.x (from 0.3.x) \u00b6 constructor / patch-rate \u00b6 OLD constructor / patch-rate class MyRoom extends Room { constructor ( options ) { super( options, PATH_RATE ) } } NEW constructor / patch-rate class MyRoom extends Room { constructor ( options ) { super( options ) this.setPatchRate( PATCH_RATE ) } }","title":"0.9.x"},{"location":"migrating/0.9/#migrating-to-version-09x-from-06x-or-08x","text":"","title":"Migrating to version 0.9.x (from 0.6.x or 0.8.x)"},{"location":"migrating/0.9/#server-side","text":"ClusterServer has been deprecated. Use Server instead. Room#verifyClient(client, options) has been renamed to Room#onAuth(options) Integration with uws module has changed. See how to integrate here .","title":"Server-side"},{"location":"migrating/0.9/#client-side","text":"","title":"Client-side"},{"location":"migrating/0.9/#colyseusjs","text":"room.onData has been renamed to room.onMessage . room.onUpdate has been renamed to room.onStateChange room.data has been renamed to room.state","title":"colyseus.js"},{"location":"migrating/0.9/#colyseus-unity3d","text":"room.OnData has been renamed to room.OnMessage . room.OnUpdate has been renamed to room.OnStateChange room.data has been renamed to room.state","title":"colyseus-unity3d"},{"location":"migrating/0.9/#migrating-to-05x-from-04x","text":"","title":"Migrating to 0.5.x (from 0.4.x)"},{"location":"migrating/0.9/#use-serverlisten-to-bind-http-port","text":"The Server is now using the ClusterServer under the hood, which will spawn workers automatically. If you're using the Server instead of ClusterServer directly, you should call its listen method. OLD import { createServer } from 'http'; import { Server } from 'colyseus'; const httpServer = createServer(app); const gameServer = new Server({ server: httpServer }); httpServer.listen(2567); NEW import { createServer } from 'http'; import { Server } from 'colyseus'; const httpServer = createServer(app); const gameServer = new Server({ server: httpServer }); gameServer.listen(2567); // calling 'listen' from gameServer instead of httpServer","title":"Use Server#listen to bind http port."},{"location":"migrating/0.9/#constructor-signature-changed-use-oncreate-instead","text":"OLD constructor (options) { super(options); // ... initialize the room } NEW constructor () { // room has been constructed. no options available yet! } onCreate (options) { // ... initialize the room }","title":"constructor signature changed. use onCreate instead."},{"location":"migrating/0.9/#requestjoin-can-return-type-can-be-either-boolean-or-number-01","text":"OLD requestJoin (options) { // accept connections if this room is not full. return this.clients.length < 10; } NEW requestJoin (options) { // give priority to connect on rooms with fewer clients. return 1 - (this.clients.length) / 10; }","title":"requestJoin - can return type can be either boolean or number (0..1)"},{"location":"migrating/0.9/#use-patchrate-property-instead-of-setpatchrate-method","text":"OLD constructor (options) { this.setPatchRate(1000 / 50); } NEW class MyRoom extends Room { patchRate = 1000 / 50; }","title":"use patchRate property instead of setPatchRate() method."},{"location":"migrating/0.9/#clientid-clientsessionid","text":"client.sessionId - is a unique identifier of a user connected in a room. client.id - is a unique identifier of a user. if the user connects to the same room twice, you can identify he has two sessions by checking for client.id . If you don't bother having the same user connected multiple times in a room, always use client.sessionId to identify it.","title":"client.id / client.sessionId"},{"location":"migrating/0.9/#new-roommaxclients-property","text":"OLD - if you're just checking for client.length on requestJoin , you probably can switch to maxClients instead. requestJoin (options) { return this.clients.length < 10; } NEW class MyRoom extends Room { maxClients = 10; }","title":"new room.maxClients property."},{"location":"migrating/0.9/#migrating-to-04x-from-03x","text":"","title":"Migrating to 0.4.x (from 0.3.x)"},{"location":"migrating/0.9/#constructor-patch-rate","text":"OLD constructor / patch-rate class MyRoom extends Room { constructor ( options ) { super( options, PATH_RATE ) } } NEW constructor / patch-rate class MyRoom extends Room { constructor ( options ) { super( options ) this.setPatchRate( PATCH_RATE ) } }","title":"constructor / patch-rate"},{"location":"server/api/","text":"Web-Socket \u670d\u52a1\u5668 \u00b6 Server \u00b6 The Server is responsible for providing the WebSocket server to enable communication between server and client. \u8be5 Server \u8d1f\u8d23\u63d0\u4f9bWebSocket\u7684\u670d\u52a1\u5668\uff0c\u4f7f\u670d\u52a1\u5668\u548c\u5ba2\u6237\u673a\u4e4b\u95f4\u7684\u901a\u4fe1\u3002 constructor (options) \u00b6 options.server \u00b6 The HTTP server to bind the WebSocket Server into. You may use express for your server too. TypeScript // Colyseus + Express import { Server } from \"colyseus\" ; import { createServer } from \"http\" ; import express from \"express\" ; const port = Number ( process . env . port ) || 3000 ; const app = express (); app . use ( express . json ()); const gameServer = new Server ({ server : createServer ( app ) }); gameServer . listen ( port ); JavaScript // Colyseus + Express const colyseus = require ( \"colyseus\" ); const http = require ( \"http\" ); const express = require ( \"express\" ); const port = process . env . port || 3000 ; const app = express (); app . use ( express . json ()); const gameServer = new colyseus . Server ({ server : http.createServer ( app ) }); gameServer . listen ( port ); TypeScript (barebones) // Colyseus (barebones) import { Server } from \"colyseus\" ; const port = process . env . port || 3000 ; const gameServer = new Server (); gameServer . listen ( port ); JavaScript (barebones) // Colyseus (barebones) const colyseus = require ( \"colyseus\" ); const port = process . env . port || 3000 ; const gameServer = new colyseus . Server (); gameServer . listen ( port ); options.pingInterval \u00b6 Number of milliseconds for the server to \"ping\" the clients. Default: 1500 The clients are going to be forcibly disconnected if they can't respond after pingMaxRetries retries. options.pingMaxRetries \u00b6 Maximum allowed number of pings without a response. Default: 2 . options.verifyClient \u00b6 This method happens before WebSocket handshake. If verifyClient is not set then the handshake is automatically accepted. info (Object) origin (String) The value in the Origin header indicated by the client. req (http.IncomingMessage) The client HTTP GET request. secure (Boolean) true if req.connection.authorized or req.connection.encrypted is set. next (Function) A callback that must be called by the user upon inspection of the info fields. Arguments in this callback are: result (Boolean) Whether or not to accept the handshake. code (Number) When result is false this field determines the HTTP error status code to be sent to the client. name (String) When result is false this field determines the HTTP reason phrase. TypeScript import { Server } from \"colyseus\" ; const gameServer = new Server ({ // ... verifyClient : function ( info , next ) { // validate 'info' // // - next(false) will reject the websocket handshake // - next(true) will accept the websocket handshake } }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... verifyClient : function ( info , next ) { // validate 'info' // // - next(false) will reject the websocket handshake // - next(true) will accept the websocket handshake } }); options.presence \u00b6 When scaling Colyseus through multiple processes / machines, you need to provide a presence server. Read more about scalability , and the Presence API . TypeScript import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... presence : new RedisPresence () }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence () }); The currently available Presence servers are currently: RedisPresence (scales on a single server and multiple servers) options.gracefullyShutdown \u00b6 Register shutdown routine automatically. Default is true . If disabled, you should call gracefullyShutdown() method manually in your shutdown process. define (name: string, handler: Room, options?: any) \u00b6 Define a new room handler. Parameters: name: string - The public name of the room. You'll use this name when joining the room from the client-side. handler: Room - Reference to the Room handler class. options?: any - Custom options for room initialization. // Define \"chat\" room gameServer . define ( \"chat\" , ChatRoom ); // Define \"battle\" room gameServer . define ( \"battle\" , BattleRoom ); // Define \"battle\" room with custom options gameServer . define ( \"battle_woods\" , BattleRoom , { map : \"woods\" }); Defining the same room handler multiple times You may define the same room handler multiple times with different options . When Room#onCreate() is called, the options will contain the merged values you specified on Server#define() + the options provided when the room is created. Matchmaking filters: filterBy(options) \u00b6 Parameters options: string[] - a list of option names Whenever a room is created by the create() or joinOrCreate() methods, only the options defined by the filterBy() method are going to be stored internally, and used to filter out rooms in further join() or joinOrCreate() calls. Example: allowing different \"game modes\". gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'mode' ]); Whenever the room is created, the mode option is going to be stored internally. client . joinOrCreate ( \"battle\" , { mode : \"duo\" }). then ( room => { /* ... */ }); You can handle the provided option in the onCreate() and/or onJoin() to implement the requested feature inside your room implementation. class BattleRoom extends Room { onCreate ( options ) { if ( options . mode === \"duo\" ) { // do something! } } onJoin ( client , options ) { if ( options . mode === \"duo\" ) { // put this player into a team! } } } Example: filtering by built-in maxClients The maxClients is an internal variable stored for matchmaking, and can be used for filtering too. gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'maxClients' ]); The client can then ask to join a room capable of handling a certain number of players. client . joinOrCreate ( \"battle\" , { maxClients : 10 }). then ( room => { /* ... */ }); client . joinOrCreate ( \"battle\" , { maxClients : 20 }). then ( room => { /* ... */ }); Matchmaking priority: sortBy(options) \u00b6 You can also give a different priority for joining rooms depending on their information upon creation. The options parameter is a key-value object containing the field name in the left, and the sorting direction in the right. Sorting direction can be one of these values: -1 , \"desc\" , \"descending\" , 1 , \"asc\" or \"ascending\" . Example: sorting by the built-in clients The clients is an internal variable stored for matchmaking, which contains the current number of connected clients. On the example below, the rooms with the highest amount of clients connected will have priority. Use -1 , \"desc\" or \"descending\" for descending order: gameServer . define ( \"battle\" , BattleRoom ) . sortBy ({ clients : - 1 }); To sort by the fewest amount of players, you can do the opposite. Use 1 , \"asc\" or \"ascending\" for ascending order: gameServer . define ( \"battle\" , BattleRoom ) . sortBy ({ clients : 1 }); Listening to room instance events \u00b6 The define method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as: \"create\" - when a room has been created \"dispose\" - when a room has been disposed \"join\" - when a client join a room \"leave\" - when a client leave a room \"lock\" - when a room has been locked \"unlock\" - when a room has been unlocked Usage: gameServer . define ( \"chat\" , ChatRoom ) . on ( \"create\" , ( room ) => console . log ( \"room created:\" , room . roomId )) . on ( \"dispose\" , ( room ) => console . log ( \"room disposed:\" , room . roomId )) . on ( \"join\" , ( room , client ) => console . log ( client . id , \"joined\" , room . roomId )) . on ( \"leave\" , ( room , client ) => console . log ( client . id , \"left\" , room . roomId )); Warning It's completely discouraged to manipulate a room's state through these events. Use the abstract methods in your room handler instead. attach (options: any) \u00b6 You usually do not need to call this. Use it only if you have a very specific reason to do so. Attaches or creates the WebSocket server. options.server : The HTTP server to attach the WebSocket server on. options.ws : An existing WebSocket server to be re-used. Express import express from \"express\" ; import { Server } from \"colyseus\" ; const app = new express (); const gameServer = new Server (); gameServer . attach ({ server : app }); http.createServer import http from \"http\" ; import { Server } from \"colyseus\" ; const httpServer = http . createServer (); const gameServer = new Server (); gameServer . attach ({ server : httpServer }); WebSocket.Server import http from \"http\" ; import express from \"express\" ; import ws from \"ws\" ; import { Server } from \"colyseus\" ; const app = express (); const server = http . createServer ( app ); const wss = new WebSocket . Server ({ // your custom WebSocket.Server setup. }); const gameServer = new Server (); gameServer . attach ({ ws : wss }); listen (port: number) \u00b6 Binds the WebSocket server into the specified port. onShutdown (callback: Function) \u00b6 Register a callback that should be called before the process shut down. See graceful shutdown for more details. gracefullyShutdown (exit: boolean) \u00b6 Shutdown all rooms and clean-up its cached data. Returns a promise that fulfils whenever the clean-up has been complete. This method is called automatically unless gracefullyShutdown: false has been provided on Server constructor.","title":"Server"},{"location":"server/api/#web-socket","text":"","title":"Web-Socket \u670d\u52a1\u5668"},{"location":"server/api/#server","text":"The Server is responsible for providing the WebSocket server to enable communication between server and client. \u8be5 Server \u8d1f\u8d23\u63d0\u4f9bWebSocket\u7684\u670d\u52a1\u5668\uff0c\u4f7f\u670d\u52a1\u5668\u548c\u5ba2\u6237\u673a\u4e4b\u95f4\u7684\u901a\u4fe1\u3002","title":"Server"},{"location":"server/api/#constructor-options","text":"","title":"constructor (options)"},{"location":"server/api/#optionsserver","text":"The HTTP server to bind the WebSocket Server into. You may use express for your server too. TypeScript // Colyseus + Express import { Server } from \"colyseus\" ; import { createServer } from \"http\" ; import express from \"express\" ; const port = Number ( process . env . port ) || 3000 ; const app = express (); app . use ( express . json ()); const gameServer = new Server ({ server : createServer ( app ) }); gameServer . listen ( port ); JavaScript // Colyseus + Express const colyseus = require ( \"colyseus\" ); const http = require ( \"http\" ); const express = require ( \"express\" ); const port = process . env . port || 3000 ; const app = express (); app . use ( express . json ()); const gameServer = new colyseus . Server ({ server : http.createServer ( app ) }); gameServer . listen ( port ); TypeScript (barebones) // Colyseus (barebones) import { Server } from \"colyseus\" ; const port = process . env . port || 3000 ; const gameServer = new Server (); gameServer . listen ( port ); JavaScript (barebones) // Colyseus (barebones) const colyseus = require ( \"colyseus\" ); const port = process . env . port || 3000 ; const gameServer = new colyseus . Server (); gameServer . listen ( port );","title":"options.server"},{"location":"server/api/#optionspinginterval","text":"Number of milliseconds for the server to \"ping\" the clients. Default: 1500 The clients are going to be forcibly disconnected if they can't respond after pingMaxRetries retries.","title":"options.pingInterval"},{"location":"server/api/#optionspingmaxretries","text":"Maximum allowed number of pings without a response. Default: 2 .","title":"options.pingMaxRetries"},{"location":"server/api/#optionsverifyclient","text":"This method happens before WebSocket handshake. If verifyClient is not set then the handshake is automatically accepted. info (Object) origin (String) The value in the Origin header indicated by the client. req (http.IncomingMessage) The client HTTP GET request. secure (Boolean) true if req.connection.authorized or req.connection.encrypted is set. next (Function) A callback that must be called by the user upon inspection of the info fields. Arguments in this callback are: result (Boolean) Whether or not to accept the handshake. code (Number) When result is false this field determines the HTTP error status code to be sent to the client. name (String) When result is false this field determines the HTTP reason phrase. TypeScript import { Server } from \"colyseus\" ; const gameServer = new Server ({ // ... verifyClient : function ( info , next ) { // validate 'info' // // - next(false) will reject the websocket handshake // - next(true) will accept the websocket handshake } }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... verifyClient : function ( info , next ) { // validate 'info' // // - next(false) will reject the websocket handshake // - next(true) will accept the websocket handshake } });","title":"options.verifyClient"},{"location":"server/api/#optionspresence","text":"When scaling Colyseus through multiple processes / machines, you need to provide a presence server. Read more about scalability , and the Presence API . TypeScript import { Server , RedisPresence } from \"colyseus\" ; const gameServer = new Server ({ // ... presence : new RedisPresence () }); JavaScript const colyseus = require ( \"colyseus\" ); const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence () }); The currently available Presence servers are currently: RedisPresence (scales on a single server and multiple servers)","title":"options.presence"},{"location":"server/api/#optionsgracefullyshutdown","text":"Register shutdown routine automatically. Default is true . If disabled, you should call gracefullyShutdown() method manually in your shutdown process.","title":"options.gracefullyShutdown"},{"location":"server/api/#define-name-string-handler-room-options-any","text":"Define a new room handler. Parameters: name: string - The public name of the room. You'll use this name when joining the room from the client-side. handler: Room - Reference to the Room handler class. options?: any - Custom options for room initialization. // Define \"chat\" room gameServer . define ( \"chat\" , ChatRoom ); // Define \"battle\" room gameServer . define ( \"battle\" , BattleRoom ); // Define \"battle\" room with custom options gameServer . define ( \"battle_woods\" , BattleRoom , { map : \"woods\" }); Defining the same room handler multiple times You may define the same room handler multiple times with different options . When Room#onCreate() is called, the options will contain the merged values you specified on Server#define() + the options provided when the room is created.","title":"define (name: string, handler: Room, options?: any)"},{"location":"server/api/#matchmaking-filters-filterbyoptions","text":"Parameters options: string[] - a list of option names Whenever a room is created by the create() or joinOrCreate() methods, only the options defined by the filterBy() method are going to be stored internally, and used to filter out rooms in further join() or joinOrCreate() calls. Example: allowing different \"game modes\". gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'mode' ]); Whenever the room is created, the mode option is going to be stored internally. client . joinOrCreate ( \"battle\" , { mode : \"duo\" }). then ( room => { /* ... */ }); You can handle the provided option in the onCreate() and/or onJoin() to implement the requested feature inside your room implementation. class BattleRoom extends Room { onCreate ( options ) { if ( options . mode === \"duo\" ) { // do something! } } onJoin ( client , options ) { if ( options . mode === \"duo\" ) { // put this player into a team! } } } Example: filtering by built-in maxClients The maxClients is an internal variable stored for matchmaking, and can be used for filtering too. gameServer . define ( \"battle\" , BattleRoom ) . filterBy ([ 'maxClients' ]); The client can then ask to join a room capable of handling a certain number of players. client . joinOrCreate ( \"battle\" , { maxClients : 10 }). then ( room => { /* ... */ }); client . joinOrCreate ( \"battle\" , { maxClients : 20 }). then ( room => { /* ... */ });","title":"Matchmaking filters: filterBy(options)"},{"location":"server/api/#matchmaking-priority-sortbyoptions","text":"You can also give a different priority for joining rooms depending on their information upon creation. The options parameter is a key-value object containing the field name in the left, and the sorting direction in the right. Sorting direction can be one of these values: -1 , \"desc\" , \"descending\" , 1 , \"asc\" or \"ascending\" . Example: sorting by the built-in clients The clients is an internal variable stored for matchmaking, which contains the current number of connected clients. On the example below, the rooms with the highest amount of clients connected will have priority. Use -1 , \"desc\" or \"descending\" for descending order: gameServer . define ( \"battle\" , BattleRoom ) . sortBy ({ clients : - 1 }); To sort by the fewest amount of players, you can do the opposite. Use 1 , \"asc\" or \"ascending\" for ascending order: gameServer . define ( \"battle\" , BattleRoom ) . sortBy ({ clients : 1 });","title":"Matchmaking priority: sortBy(options)"},{"location":"server/api/#listening-to-room-instance-events","text":"The define method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as: \"create\" - when a room has been created \"dispose\" - when a room has been disposed \"join\" - when a client join a room \"leave\" - when a client leave a room \"lock\" - when a room has been locked \"unlock\" - when a room has been unlocked Usage: gameServer . define ( \"chat\" , ChatRoom ) . on ( \"create\" , ( room ) => console . log ( \"room created:\" , room . roomId )) . on ( \"dispose\" , ( room ) => console . log ( \"room disposed:\" , room . roomId )) . on ( \"join\" , ( room , client ) => console . log ( client . id , \"joined\" , room . roomId )) . on ( \"leave\" , ( room , client ) => console . log ( client . id , \"left\" , room . roomId )); Warning It's completely discouraged to manipulate a room's state through these events. Use the abstract methods in your room handler instead.","title":"Listening to room instance events"},{"location":"server/api/#attach-options-any","text":"You usually do not need to call this. Use it only if you have a very specific reason to do so. Attaches or creates the WebSocket server. options.server : The HTTP server to attach the WebSocket server on. options.ws : An existing WebSocket server to be re-used. Express import express from \"express\" ; import { Server } from \"colyseus\" ; const app = new express (); const gameServer = new Server (); gameServer . attach ({ server : app }); http.createServer import http from \"http\" ; import { Server } from \"colyseus\" ; const httpServer = http . createServer (); const gameServer = new Server (); gameServer . attach ({ server : httpServer }); WebSocket.Server import http from \"http\" ; import express from \"express\" ; import ws from \"ws\" ; import { Server } from \"colyseus\" ; const app = express (); const server = http . createServer ( app ); const wss = new WebSocket . Server ({ // your custom WebSocket.Server setup. }); const gameServer = new Server (); gameServer . attach ({ ws : wss });","title":"attach (options: any)"},{"location":"server/api/#listen-port-number","text":"Binds the WebSocket server into the specified port.","title":"listen (port: number)"},{"location":"server/api/#onshutdown-callback-function","text":"Register a callback that should be called before the process shut down. See graceful shutdown for more details.","title":"onShutdown (callback: Function)"},{"location":"server/api/#gracefullyshutdown-exit-boolean","text":"Shutdown all rooms and clean-up its cached data. Returns a promise that fulfils whenever the clean-up has been complete. This method is called automatically unless gracefullyShutdown: false has been provided on Server constructor.","title":"gracefullyShutdown (exit: boolean)"},{"location":"server/authentication/","text":"You may implement the onAuth (client, options) method to validate the authenticity of your clients. The onAuth() method will be executed before onJoin() . You can use it to validate if the player is allowed to join the room. From the client-side, you'd call the join method with a token from some authentication service of your choice (i. e. Facebook): JavaScript client . joinOrCreate ( \"world\" , { accessToken : yourFacebookAccessToken }). then ( room => { // success }). catch ( err => { // handle error... }); C# try { var room = client . JoinOrCreate < YourStateClass >( \"world\" , new { accessToken = yourFacebookAccessToken }); // success } catch ( ex ) { // handle error... } Lua client : join_or_create ( \"world\" , { accessToken = yourFacebookAccessToken }, function ( err , room ) -- success end ) Haxe client . joinOrCreate ( \"world\" , { accessToken : yourFacebookAccessToken }, YourStateClass , function ( err , room ) { if ( err != null ) { // handle error... return ; } // success }) C++ client . joinOrCreate ( \"world\" , {{ \"accessToken\" , yourFacebookAccessToken }}, [ = ]( std :: string err , Room < YourStateClass >* room ) { if ( err != \"\" ) { // handle error... return ; } // success }); The onAuth method in your room handler should return a truthy value if the access token is valid. You may also return custom user-related data, which will be passed on the third parameter of onJoin . Synchronous usage \u00b6 You can immediatelly return a boolean value. import { Room } from \"colyseus\" ; class MyRoom extends Room { onAuth ( client , options ) : boolean { return ( options . password === \"secret\" ); } } Asynchronous usage \u00b6 You can return a Promise , and perform some asynchronous task to validate the client. import { Room } from \"colyseus\" ; class MyRoom extends Room { onAuth ( client , options ) : Promise < any > { return new Promise (( resolve , reject ) => { validateToken ( options . accessToken , ( err , userData ) => { if ( ! err ) { resolve ( userData ); } else { reject ( err ); } }); }); } } Alternatively, you can use async / await , which will return a Promise under the hood. import { Room } from \"colyseus\" ; class MyRoom extends Room { async onAuth ( client , options ) { const userData = await validateToken ( options . accessToken ); return ( userData ) ? userData : false ; } }","title":"Authentication API"},{"location":"server/authentication/#synchronous-usage","text":"You can immediatelly return a boolean value. import { Room } from \"colyseus\" ; class MyRoom extends Room { onAuth ( client , options ) : boolean { return ( options . password === \"secret\" ); } }","title":"Synchronous usage"},{"location":"server/authentication/#asynchronous-usage","text":"You can return a Promise , and perform some asynchronous task to validate the client. import { Room } from \"colyseus\" ; class MyRoom extends Room { onAuth ( client , options ) : Promise < any > { return new Promise (( resolve , reject ) => { validateToken ( options . accessToken , ( err , userData ) => { if ( ! err ) { resolve ( userData ); } else { reject ( err ); } }); }); } } Alternatively, you can use async / await , which will return a Promise under the hood. import { Room } from \"colyseus\" ; class MyRoom extends Room { async onAuth ( client , options ) { const userData = await validateToken ( options . accessToken ); return ( userData ) ? userData : false ; } }","title":"Asynchronous usage"},{"location":"server/client/","text":"Web-Socket Client \u00b6 The client instance present on: Room#clients Room#onJoin() Room#onMessage() Room#onLeave() Note This is the raw WebSocket connection coming from the ws package. There are more methods available which aren't encouraged to use along with Colyseus. Properties \u00b6 id: string \u00b6 Alias to sessionId . sessionId: string \u00b6 Unique id per session. Note In the client-side, you can find the sessionId in the room instance . auth: any \u00b6 Custom data you return during onAuth() . Methods \u00b6 close(code?: number) \u00b6 Force disconnection of the client with the server. Tip This will trigger room.onLeave event on the client-side.","title":"Client"},{"location":"server/client/#web-socket-client","text":"The client instance present on: Room#clients Room#onJoin() Room#onMessage() Room#onLeave() Note This is the raw WebSocket connection coming from the ws package. There are more methods available which aren't encouraged to use along with Colyseus.","title":"Web-Socket Client"},{"location":"server/client/#properties","text":"","title":"Properties"},{"location":"server/client/#id-string","text":"Alias to sessionId .","title":"id: string"},{"location":"server/client/#sessionid-string","text":"Unique id per session. Note In the client-side, you can find the sessionId in the room instance .","title":"sessionId: string"},{"location":"server/client/#auth-any","text":"Custom data you return during onAuth() .","title":"auth: any"},{"location":"server/client/#methods","text":"","title":"Methods"},{"location":"server/client/#closecode-number","text":"Force disconnection of the client with the server. Tip This will trigger room.onLeave event on the client-side.","title":"close(code?: number)"},{"location":"server/graceful-shutdown/","text":"Graceful Shutdown \u00b6 Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself: Disconnect all connected clients asynchronously ( Room#onLeave ) Dispose all spawned rooms asynchronously ( Room#onDispose ) Perform optional asynchronous callback before shutting down the process Server#onShutdown If you're performing async tasks on onLeave / onDispose , you should return a Promise , and resolve it when the task is ready. The same applies to onShutdown(callback) . Returning a Promise \u00b6 By returning a Promise , the server will wait for them to be completed before killing the worker process. import { Room } from \"colyseus\" ; class MyRoom extends Room { onLeave ( client ) { return new Promise (( resolve , reject ) => { doDatabaseOperation (( err , data ) => { if ( err ) { reject ( err ); } else { resolve ( data ); } }); }); } onDispose () { return new Promise (( resolve , reject ) => { doDatabaseOperation (( err , data ) => { if ( err ) { reject ( err ); } else { resolve ( data ); } }); }); } } Using async \u00b6 The async keyword will makes your function return a Promise under the hood. Read more about Async / Await . import { Room } from \"colyseus\" ; class MyRoom extends Room { async onLeave ( client ) { await doDatabaseOperation ( client ); } async onDispose () { await removeRoomFromDatabase (); } } Process shutdown callback \u00b6 You can also listen for process shutdown by setting a onShutdown callback. import { Server } from \"colyseus\" ; let server = new Server (); server . onShutdown ( function () { console . log ( \"master process is being shut down!\" ); });","title":"Graceful shutdown"},{"location":"server/graceful-shutdown/#graceful-shutdown","text":"Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself: Disconnect all connected clients asynchronously ( Room#onLeave ) Dispose all spawned rooms asynchronously ( Room#onDispose ) Perform optional asynchronous callback before shutting down the process Server#onShutdown If you're performing async tasks on onLeave / onDispose , you should return a Promise , and resolve it when the task is ready. The same applies to onShutdown(callback) .","title":"Graceful Shutdown"},{"location":"server/graceful-shutdown/#returning-a-promise","text":"By returning a Promise , the server will wait for them to be completed before killing the worker process. import { Room } from \"colyseus\" ; class MyRoom extends Room { onLeave ( client ) { return new Promise (( resolve , reject ) => { doDatabaseOperation (( err , data ) => { if ( err ) { reject ( err ); } else { resolve ( data ); } }); }); } onDispose () { return new Promise (( resolve , reject ) => { doDatabaseOperation (( err , data ) => { if ( err ) { reject ( err ); } else { resolve ( data ); } }); }); } }","title":"Returning a Promise"},{"location":"server/graceful-shutdown/#using-async","text":"The async keyword will makes your function return a Promise under the hood. Read more about Async / Await . import { Room } from \"colyseus\" ; class MyRoom extends Room { async onLeave ( client ) { await doDatabaseOperation ( client ); } async onDispose () { await removeRoomFromDatabase (); } }","title":"Using async"},{"location":"server/graceful-shutdown/#process-shutdown-callback","text":"You can also listen for process shutdown by setting a onShutdown callback. import { Server } from \"colyseus\" ; let server = new Server (); server . onShutdown ( function () { console . log ( \"master process is being shut down!\" ); });","title":"Process shutdown callback"},{"location":"server/matchmaker/","text":"You may not need this! This section is for advanced usage. You're usually good to go by using the client-side methods . If you think you can't achieve your goal with the client-side methods, you should consider using the ones described on this page. The methods described below are provided by the matchMaker singleton, which can be imported from the \"colyseus\" package: TypeScript import { matchMaker } from \"colyseus\" ; JavaScript const matchMaker = require ( \"colyseus\" ). matchMaker ; .joinOrCreate(roomName, options) \u00b6 Join or create a room and return a client seat reservation. Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . joinOrCreate ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. .create(roomName, options) \u00b6 Create a new room and return client seat reservation. Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . create ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. .join(roomName, options) \u00b6 Join a room and return seat reservation. An exception is thrown if there are no rooms available for roomName . Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . join ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. .joinById(roomId, options) \u00b6 Join a room by id and return client seat reservation. An exception is thrown if room is not found for roomId . Parameters: roomId : the id of a specific room instance. options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . joinById ( \"xxxxxxxxx\" , {}); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. .query(conditions) \u00b6 Perform a query against cached rooms. const rooms = await matchMaker . query ({ name : \"battle\" , mode : \"duo\" }); console . log ( rooms ); /* [ { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false }, { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false }, { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } ] */ .findOneRoomAvailable(roomName, options) \u00b6 Find for a public and unlocked room available Parameters: roomId : the id of a specific room instance. options : options for the client seat reservation (for onJoin / onAuth ) const room = await matchMaker . findOneRoomAvailable ( \"battle\" , { mode : \"duo\" }); console . log ( room ); /* { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } */ .remoteRoomCall(roomId, method, args) \u00b6 Call a method or return a property on a remote room. Parameters: roomId : the id of a specific room instance. method : method or attribute to call or retrieve args : array of arguments // call lock() on a remote room by id await matchMaker . remoteRoomCall ( \"xxxxxxxxx\" , \"lock\" ); .createRoom(roomName, options) \u00b6 Create a new room Parameters: roomName : the identifier you defined on gameServer.define() . options : options for onCreate const room = await matchMaker . createRoom ( \"battle\" , { mode : \"duo\" }); console . log ( room ); /* { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } */ .reserveSeatFor(room, options) \u00b6 Reserve a seat for a client in a room. Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. Parameters: room : room data (result from createRoom() , etc) options : options for onCreate const reservation = await matchMaker . reserveSeatFor ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */","title":"Match-maker API"},{"location":"server/matchmaker/#joinorcreateroomname-options","text":"Join or create a room and return a client seat reservation. Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . joinOrCreate ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat.","title":".joinOrCreate(roomName, options)"},{"location":"server/matchmaker/#createroomname-options","text":"Create a new room and return client seat reservation. Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . create ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat.","title":".create(roomName, options)"},{"location":"server/matchmaker/#joinroomname-options","text":"Join a room and return seat reservation. An exception is thrown if there are no rooms available for roomName . Parameters: roomName : the identifier you defined on gameServer.define() . options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . join ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat.","title":".join(roomName, options)"},{"location":"server/matchmaker/#joinbyidroomid-options","text":"Join a room by id and return client seat reservation. An exception is thrown if room is not found for roomId . Parameters: roomId : the id of a specific room instance. options : options for the client seat reservation (for onJoin / onAuth ) const reservation = await matchMaker . joinById ( \"xxxxxxxxx\" , {}); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */ Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat.","title":".joinById(roomId, options)"},{"location":"server/matchmaker/#queryconditions","text":"Perform a query against cached rooms. const rooms = await matchMaker . query ({ name : \"battle\" , mode : \"duo\" }); console . log ( rooms ); /* [ { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false }, { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false }, { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } ] */","title":".query(conditions)"},{"location":"server/matchmaker/#findoneroomavailableroomname-options","text":"Find for a public and unlocked room available Parameters: roomId : the id of a specific room instance. options : options for the client seat reservation (for onJoin / onAuth ) const room = await matchMaker . findOneRoomAvailable ( \"battle\" , { mode : \"duo\" }); console . log ( room ); /* { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } */","title":".findOneRoomAvailable(roomName, options)"},{"location":"server/matchmaker/#remoteroomcallroomid-method-args","text":"Call a method or return a property on a remote room. Parameters: roomId : the id of a specific room instance. method : method or attribute to call or retrieve args : array of arguments // call lock() on a remote room by id await matchMaker . remoteRoomCall ( \"xxxxxxxxx\" , \"lock\" );","title":".remoteRoomCall(roomId, method, args)"},{"location":"server/matchmaker/#createroomroomname-options","text":"Create a new room Parameters: roomName : the identifier you defined on gameServer.define() . options : options for onCreate const room = await matchMaker . createRoom ( \"battle\" , { mode : \"duo\" }); console . log ( room ); /* { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } */","title":".createRoom(roomName, options)"},{"location":"server/matchmaker/#reserveseatforroom-options","text":"Reserve a seat for a client in a room. Consuming the seat reservation You can use consumeSeatReservation() from the client-side to join the room by its reserved seat. Parameters: room : room data (result from createRoom() , etc) options : options for onCreate const reservation = await matchMaker . reserveSeatFor ( \"battle\" , { mode : \"duo\" }); console . log ( reservation ); /* { \"sessionId\": \"zzzzzzzzz\", \"room\": { \"roomId\": \"xxxxxxxxx\", \"processId\": \"yyyyyyyyy\", \"name\": \"battle\", \"locked\": false } } */","title":".reserveSeatFor(room, options)"},{"location":"server/presence/","text":"Presence \u00b6 When you need to scale your server on multiple processes and/or machines, you'd need to provide the Presence option to the Server . The purpose of Presence is to allow communicating and sharing data between different processes, specially during match-making. LocalPresence (default) RedisPresence The presence instance is also available on every Room handler. You may use its API to persist data and communicate between rooms via PUB/SUB. LocalPresence \u00b6 This is the default option. It's meant to be used when you're running Colyseus in a single process. RedisPresence (clientOpts?) \u00b6 Use this option when you're running Colyseus on multiple processes and/or machines. Parameters: clientOpts : The redis client options (host/credentials). See full list of options . TypeScript import { Server , RedisPresence } from \"colyseus\" ; // This happens on the slave processes. const gameServer = new Server ({ // ... presence : new RedisPresence () }); gameServer . listen ( 2567 ); JavaScript const colyseus = require ( 'colyseus' ); // This happens on the slave processes. const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence () }); gameServer . listen ( 2567 ); API \u00b6 The Presence API is highly based on Redis's API, which is a key-value database. Every Room instance has a presence property, which implements the following methods: subscribe(topic: string, callback: Function) \u00b6 Subscribes to the given topic . The callback will be triggered whenever a message is published on topic . unsubscribe(topic: string) \u00b6 Unsubscribe from given topic . publish(topic: string, data: any) \u00b6 Posts a message to given topic . exists(key: string): Promise<boolean> \u00b6 Returns if key exists. setex(key: string, value: string, seconds: number) \u00b6 Set key to hold the string value and set key to timeout after a given number of seconds. get(key: string) \u00b6 Get the value of key. del(key: string): void \u00b6 Removes the specified key. sadd(key: string, value: any) \u00b6 Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members. smembers(key: string) \u00b6 Returns all the members of the set value stored at key. srem(key: string, value: any) \u00b6 Remove the specified members from the set stored at key. Specified members that are not a member of this set are ignored. If key does not exist, it is treated as an empty set and this command returns 0. scard(key: string) \u00b6 Returns the set cardinality (number of elements) of the set stored at key. sinter(...keys: string[]) \u00b6 Returns the members of the set resulting from the intersection of all the given sets. hset(key: string, field: string, value: string) \u00b6 Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten. hincrby(key: string, field: string, value: number) \u00b6 Increments the number stored at field in the hash stored at key by increment. If key does not exist, a new key holding a hash is created. If field does not exist the value is set to 0 before the operation is performed. hget(key: string, field: string): Promise<string> \u00b6 Returns the value associated with field in the hash stored at key. hgetall(key: string): Promise<{[field: string]: string}> \u00b6 Returns all fields and values of the hash stored at key. hdel(key: string, field: string) \u00b6 Removes the specified fields from the hash stored at key. Specified fields that do not exist within this hash are ignored. If key does not exist, it is treated as an empty hash and this command returns 0. hlen(key: string): Promise<number> \u00b6 Returns the number of fields contained in the hash stored at key incr(key: string) \u00b6 Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers. decr(key: string) \u00b6 Decrements the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.","title":"Presence"},{"location":"server/presence/#presence","text":"When you need to scale your server on multiple processes and/or machines, you'd need to provide the Presence option to the Server . The purpose of Presence is to allow communicating and sharing data between different processes, specially during match-making. LocalPresence (default) RedisPresence The presence instance is also available on every Room handler. You may use its API to persist data and communicate between rooms via PUB/SUB.","title":"Presence"},{"location":"server/presence/#localpresence","text":"This is the default option. It's meant to be used when you're running Colyseus in a single process.","title":"LocalPresence"},{"location":"server/presence/#redispresence-clientopts","text":"Use this option when you're running Colyseus on multiple processes and/or machines. Parameters: clientOpts : The redis client options (host/credentials). See full list of options . TypeScript import { Server , RedisPresence } from \"colyseus\" ; // This happens on the slave processes. const gameServer = new Server ({ // ... presence : new RedisPresence () }); gameServer . listen ( 2567 ); JavaScript const colyseus = require ( 'colyseus' ); // This happens on the slave processes. const gameServer = new colyseus . Server ({ // ... presence : new colyseus . RedisPresence () }); gameServer . listen ( 2567 );","title":"RedisPresence (clientOpts?)"},{"location":"server/presence/#api","text":"The Presence API is highly based on Redis's API, which is a key-value database. Every Room instance has a presence property, which implements the following methods:","title":"API"},{"location":"server/presence/#subscribetopic-string-callback-function","text":"Subscribes to the given topic . The callback will be triggered whenever a message is published on topic .","title":"subscribe(topic: string, callback: Function)"},{"location":"server/presence/#unsubscribetopic-string","text":"Unsubscribe from given topic .","title":"unsubscribe(topic: string)"},{"location":"server/presence/#publishtopic-string-data-any","text":"Posts a message to given topic .","title":"publish(topic: string, data: any)"},{"location":"server/presence/#existskey-string-promiseltbooleangt","text":"Returns if key exists.","title":"exists(key: string): Promise&amp;lt;boolean&amp;gt;"},{"location":"server/presence/#setexkey-string-value-string-seconds-number","text":"Set key to hold the string value and set key to timeout after a given number of seconds.","title":"setex(key: string, value: string, seconds: number)"},{"location":"server/presence/#getkey-string","text":"Get the value of key.","title":"get(key: string)"},{"location":"server/presence/#delkey-string-void","text":"Removes the specified key.","title":"del(key: string): void"},{"location":"server/presence/#saddkey-string-value-any","text":"Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.","title":"sadd(key: string, value: any)"},{"location":"server/presence/#smemberskey-string","text":"Returns all the members of the set value stored at key.","title":"smembers(key: string)"},{"location":"server/presence/#sremkey-string-value-any","text":"Remove the specified members from the set stored at key. Specified members that are not a member of this set are ignored. If key does not exist, it is treated as an empty set and this command returns 0.","title":"srem(key: string, value: any)"},{"location":"server/presence/#scardkey-string","text":"Returns the set cardinality (number of elements) of the set stored at key.","title":"scard(key: string)"},{"location":"server/presence/#sinterkeys-string","text":"Returns the members of the set resulting from the intersection of all the given sets.","title":"sinter(...keys: string[])"},{"location":"server/presence/#hsetkey-string-field-string-value-string","text":"Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.","title":"hset(key: string, field: string, value: string)"},{"location":"server/presence/#hincrbykey-string-field-string-value-number","text":"Increments the number stored at field in the hash stored at key by increment. If key does not exist, a new key holding a hash is created. If field does not exist the value is set to 0 before the operation is performed.","title":"hincrby(key: string, field: string, value: number)"},{"location":"server/presence/#hgetkey-string-field-string-promiseltstringgt","text":"Returns the value associated with field in the hash stored at key.","title":"hget(key: string, field: string): Promise&amp;lt;string&amp;gt;"},{"location":"server/presence/#hgetallkey-string-promiseltfield-string-stringgt","text":"Returns all fields and values of the hash stored at key.","title":"hgetall(key: string): Promise&amp;lt;{[field: string]: string}&amp;gt;"},{"location":"server/presence/#hdelkey-string-field-string","text":"Removes the specified fields from the hash stored at key. Specified fields that do not exist within this hash are ignored. If key does not exist, it is treated as an empty hash and this command returns 0.","title":"hdel(key: string, field: string)"},{"location":"server/presence/#hlenkey-string-promiseltnumbergt","text":"Returns the number of fields contained in the hash stored at key","title":"hlen(key: string): Promise&amp;lt;number&amp;gt;"},{"location":"server/presence/#incrkey-string","text":"Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.","title":"incr(key: string)"},{"location":"server/presence/#decrkey-string","text":"Decrements the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.","title":"decr(key: string)"},{"location":"server/room/","text":"Room API (Server-side) \u00b6 Considering that you already set up your server , now it's time to register room handlers and start accepting connections from your users. You'll define room handlers creating classes that extend from Room . TypeScript import http from \"http\" ; import { Room , Client } from \"colyseus\" ; export class MyRoom extends Room { // When room is initialized onCreate ( options : any ) { } // Authorize client based on provided options before WebSocket handshake is complete onAuth ( client : Client , options : any , request : http.IncomingMessage ) { } // When client successfully join the room onJoin ( client : Client , options : any , auth : any ) { } // When a client sends a message onMessage ( client : Client , message : any ) { } // When a client leaves the room onLeave ( client : Client , consented : boolean ) { } // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) onDispose () { } } JavaScript const colyseus = require ( 'colyseus' ); export class MyRoom extends colyseus . Room { // When room is initialized onCreate ( options ) { } // Authorize client based on provided options before WebSocket handshake is complete onAuth ( client , options , request ) { } // When client successfully join the room onJoin ( client , options , auth ) { } // When a client sends a message onMessage ( client , message ) { } // When a client leaves the room onLeave ( client , consented ) { } // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) onDispose () { } } Abstract methods \u00b6 Room handlers can implement all of these methods. onCreate (options) \u00b6 Is called once when the room is initialized. You may specify custom initialization options when registering the room handler. Tip The options will contain the merged values you specified on Server#define() + the options provided by client.joinOrCreate() or client.create() onAuth (client, options, request) \u00b6 Can be used to verify authenticity of the client that's joining the room. If left non-implemented it returns true , allowing any client to connect. See Authentication API section. Getting player's IP address You can use the request variable to retrieve the user's IP address, http headers, and more. E.g.: request.headers['x-forwarded-for'] || request.connection.remoteAddress onJoin (client, options, auth?) \u00b6 Parameters: client : The client instance. options : merged values specified on Server#define() with the options provided the client on client.join() auth : (optional) auth data returned by onAuth method. Is called when the client successfully joins the room, after requestJoin and onAuth has succeeded. onMessage (client, data) \u00b6 Is called when a client sends a message to the server. Here's where you'll process client actions to update the Room State onLeave (client, consented) \u00b6 Is called when a client leaves the room. If the disconnection was initiated by the client , the consented parameter will be true , otherwise, it will be false . You can define this function as async . See graceful shutdown onDispose () \u00b6 Cleanup callback, called after there are no more clients in the room. You can define this function as async . See graceful shutdown Example room \u00b6 This example demonstrates an entire room implementing the onCreate , onJoin and onMessage methods. import { Room , Client } from \"colyseus\" ; import { Schema , MapSchema , type } from \"@colyseus/schema\" ; // An abstract player object, demonstrating a potential 2D world position export class Player { x : number = 0.11 ; y : number = 2.22 ; } // Our custom game state, an ArraySchema of type Player only at the moment export class State extends Schema { @type ({ map : \"string\" }) players = new MapSchema < Player > (); } export class GameRoom extends Room < State > { // Colyseus will invoke when creating the room instance onCreate ( options : any ) { // initialize empty room state this . setState ( new State ()); } // Called every time a client joins onJoin ( client : Client , options : any ) { this . state . players [ client . sessionId ] = new Player (); } // Called every time this room receives a message onMessage ( client : Client , message : any ) { // Retrieve a previously stored player by their sessionId const player = this . state . players [ client . sessionId ]; // Pretend that we sent the room the message: {command: \"left\"} if ( message . command === \"left\" ) { player . x -= 1 ; } else if ( message . command === \"right\" ) { player . x += 1 ; } console . log ( client . sessionId + \" at, x: \" + player . x , \"y: \" + player . y ); } } Public properties \u00b6 roomId: string \u00b6 A unique, auto-generated, 9-character-long id of the room. roomName: string \u00b6 The name of the room you provided as first argument for gameServer.define() . state: T \u00b6 The state instance you provided to setState() . clients: WebSocket[] \u00b6 The array of connected clients. See Web-Socket Client . maxClients: number \u00b6 Maximum number of clients allowed to connect into the room. When room reaches this limit, it is locked automatically. Unless the room was explicitly locked by you via lock() method, the room will be unlocked as soon as a client disconnects from it. patchRate: number \u00b6 Frequency to send the room state to connected clients, in milliseconds. Default is 50 ms (20fps) autoDispose: boolean \u00b6 Automatically dispose the room when last client disconnect. Default is true locked: boolean (read-only) \u00b6 This property will change on these situations: The maximum number of allowed clients has been reached ( maxClients ) You manually locked, or unlocked the room using lock() or unlock() . clock: ClockTimer \u00b6 A ClockTimer instance, used for timing events . presence: Presence \u00b6 The presence instance. Check Presence API for more details. Public methods \u00b6 Room handlers have these methods available. setState (object) \u00b6 Set the new room state instance. See State Handling for more details on the state object. It's highly recommended to use the new Schema Serializer to handle your state. Warning Do not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it. Tip You usually will call this method only once during onCreate() in your room handler. setSimulationInterval (callback[, milliseconds=16.6]) \u00b6 (Optional) Set a simulation interval that can change the state of the game. The simulation interval is your game loop. Default simulation interval: 16.6ms (60fps) onCreate () { this . setSimulationInterval (( deltaTime ) => this . update ( deltaTime )); } update ( deltaTime ) { // implement your physics or world updates here! // this is a good place to update the room state } setPatchRate (milliseconds) \u00b6 Set frequency the patched state should be sent to all clients. Default is 50ms (20fps) setPrivate (bool) \u00b6 Set the room listing as private (or revert to public, if false is provided). Private rooms are not listed in the getAvailableRooms() method. setMetadata (metadata) \u00b6 Set metadata to this room. Each room instance may have metadata attached to it - the only purpose for attaching metadata is to differentiate one room from another when getting the list of available rooms from the client-side, to connect to it by its roomId , using client.getAvailableRooms() . // server-side this . setMetadata ({ friendlyFire : true }); Now that a room has metadata attached to it, the client-side can check which room has friendlyFire , for example, and connect directly to it via its roomId : // client-side client . getAvailableRooms ( \"battle\" ). then ( rooms => { for ( var i = 0 ; i < rooms . length ; i ++ ) { if ( room . metadata && room . metadata . friendlyFire ) { // // join the room with `friendlyFire` by id: // var room = client . join ( room . roomId ); return ; } } }); Tip See how to call getAvailableRooms() in other languages. setSeatReservationTime (seconds) \u00b6 Set the number of seconds a room can wait for a client to effectively join the room. You should consider how long your onAuth() will have to wait for setting a different seat reservation time. The default value is usually enough. (8 seconds) send (client, message) \u00b6 Send a message to a particular client. The message can be either a plain JavaScript object, or a Schema instance. Sending a msgpack-encoded message: This is the recommended way if you're using an interpreted language on the client-side, such as JavaScript or LUA. this . send ( client , { message : \"Hello world!\" }); Sending a schema-encoded message: Sending schema-encoded messages is particularly useful for statically-typed languages such as C#. class MyMessage extends Schema { @type ( \"string\" ) message : string ; } const data = new MyMessage (); data . message = \"Hello world!\" ; this . send ( client , data ); Tip See how to handle these messages on client-side. broadcast (message, options?) \u00b6 Send a message to all connected clients. Available options are: except : a Client instance not to send the message to afterNextPatch : waits until next patch to broadcast the message Broadcast examples \u00b6 Broadcasting a message to all clients: onMessage ( client , message ) { if ( message === \"action\" ) { // broadcast a message to all clients this . broadcast ( \"an action has been taken!\" ); } } Broadcasting a message to all clients, except the sender. onMessage ( client , message ) { if ( message === \"fire\" ) { // sends \"fire\" event to every client, except the one who triggered it. this . broadcast ( \"fire!\" , { except : client }); } } Broadcasting a message to all clients, only after a change in the state has been applied: onMessage ( client , message ) { if ( message === \"destroy\" ) { // perform changes in your state! this . state . destroySomething (); // this message will arrive only after new state has been applied this . broadcast ( \"has been destroyed!\" , { afterNextPatch : true }); } } Broadcasting a schema-encoded message: class MyMessage extends Schema { @type ( \"string\" ) message : string ; } // ... onMessage ( client , message ) { if ( message === \"action\" ) { const data = new MyMessage (); data . message = \"an action has been taken!\" ; this . broadcast ( data ); } } Tip See how to handle these onMessage() in the client-side. lock () \u00b6 Locking the room will remove it from the pool of available rooms for new clients to connect to. unlock () \u00b6 Unlocking the room returns it to the pool of available rooms for new clients to connect to. allowReconnection (client, seconds?) \u00b6 Allow the specified client to reconnect into the room. Must be used inside onLeave() method. If seconds is provided, the reconnection is going to be cancelled after the provided amout of seconds. async onLeave ( client , consented : boolean ) { // flag client as inactive for other users this . state . players [ client . sessionId ]. connected = false ; try { if ( consented ) { throw new Error ( \"consented leave\" ); } // allow disconnected client to reconnect into this room until 20 seconds await this . allowReconnection ( client , 20 ); // client returned! let's re-activate it. this . state . players [ client . sessionId ]. connected = true ; } catch ( e ) { // 20 seconds expired. let's remove the client. delete this . state . players [ client . sessionId ]; } } Alternatively, you may not provide the amount of seconds to automatically reject the reconnection, and reject it yourself using your own logic. async onLeave ( client , consented : boolean ) { // flag client as inactive for other users this . state . players [ client . sessionId ]. connected = false ; try { if ( consented ) { throw new Error ( \"consented leave\" ); } // get reconnection token const reconnection = this . allowReconnection ( client ); // // here is the custom logic for rejecting the reconnection. // for demonstration purposes of the API, an interval is created // rejecting the reconnection if the player has missed 2 rounds, // (assuming he's playing a turn-based game) // // in a real scenario, you would store the `reconnection` in // your Player instance, for example, and perform this check during your // game loop logic // const currentRound = this . state . currentRound ; const interval = setInterval (() => { if (( this . state . currentRound - currentRound ) > 2 ) { // manually reject the client reconnection reconnection . reject (); clearInterval ( interval ); } }, 1000 ); // allow disconnected client to reconnect await reconnection ; // client returned! let's re-activate it. this . state . players [ client . sessionId ]. connected = true ; } catch ( e ) { // 20 seconds expired. let's remove the client. delete this . state . players [ client . sessionId ]; } } disconnect () \u00b6 Disconnect all clients, then dispose.","title":"Room"},{"location":"server/room/#room-api-server-side","text":"Considering that you already set up your server , now it's time to register room handlers and start accepting connections from your users. You'll define room handlers creating classes that extend from Room . TypeScript import http from \"http\" ; import { Room , Client } from \"colyseus\" ; export class MyRoom extends Room { // When room is initialized onCreate ( options : any ) { } // Authorize client based on provided options before WebSocket handshake is complete onAuth ( client : Client , options : any , request : http.IncomingMessage ) { } // When client successfully join the room onJoin ( client : Client , options : any , auth : any ) { } // When a client sends a message onMessage ( client : Client , message : any ) { } // When a client leaves the room onLeave ( client : Client , consented : boolean ) { } // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) onDispose () { } } JavaScript const colyseus = require ( 'colyseus' ); export class MyRoom extends colyseus . Room { // When room is initialized onCreate ( options ) { } // Authorize client based on provided options before WebSocket handshake is complete onAuth ( client , options , request ) { } // When client successfully join the room onJoin ( client , options , auth ) { } // When a client sends a message onMessage ( client , message ) { } // When a client leaves the room onLeave ( client , consented ) { } // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) onDispose () { } }","title":"Room API (Server-side)"},{"location":"server/room/#abstract-methods","text":"Room handlers can implement all of these methods.","title":"Abstract methods"},{"location":"server/room/#oncreate-options","text":"Is called once when the room is initialized. You may specify custom initialization options when registering the room handler. Tip The options will contain the merged values you specified on Server#define() + the options provided by client.joinOrCreate() or client.create()","title":"onCreate (options)"},{"location":"server/room/#onauth-client-options-request","text":"Can be used to verify authenticity of the client that's joining the room. If left non-implemented it returns true , allowing any client to connect. See Authentication API section. Getting player's IP address You can use the request variable to retrieve the user's IP address, http headers, and more. E.g.: request.headers['x-forwarded-for'] || request.connection.remoteAddress","title":"onAuth (client, options, request)"},{"location":"server/room/#onjoin-client-options-auth","text":"Parameters: client : The client instance. options : merged values specified on Server#define() with the options provided the client on client.join() auth : (optional) auth data returned by onAuth method. Is called when the client successfully joins the room, after requestJoin and onAuth has succeeded.","title":"onJoin (client, options, auth?)"},{"location":"server/room/#onmessage-client-data","text":"Is called when a client sends a message to the server. Here's where you'll process client actions to update the Room State","title":"onMessage (client, data)"},{"location":"server/room/#onleave-client-consented","text":"Is called when a client leaves the room. If the disconnection was initiated by the client , the consented parameter will be true , otherwise, it will be false . You can define this function as async . See graceful shutdown","title":"onLeave (client, consented)"},{"location":"server/room/#ondispose","text":"Cleanup callback, called after there are no more clients in the room. You can define this function as async . See graceful shutdown","title":"onDispose ()"},{"location":"server/room/#example-room","text":"This example demonstrates an entire room implementing the onCreate , onJoin and onMessage methods. import { Room , Client } from \"colyseus\" ; import { Schema , MapSchema , type } from \"@colyseus/schema\" ; // An abstract player object, demonstrating a potential 2D world position export class Player { x : number = 0.11 ; y : number = 2.22 ; } // Our custom game state, an ArraySchema of type Player only at the moment export class State extends Schema { @type ({ map : \"string\" }) players = new MapSchema < Player > (); } export class GameRoom extends Room < State > { // Colyseus will invoke when creating the room instance onCreate ( options : any ) { // initialize empty room state this . setState ( new State ()); } // Called every time a client joins onJoin ( client : Client , options : any ) { this . state . players [ client . sessionId ] = new Player (); } // Called every time this room receives a message onMessage ( client : Client , message : any ) { // Retrieve a previously stored player by their sessionId const player = this . state . players [ client . sessionId ]; // Pretend that we sent the room the message: {command: \"left\"} if ( message . command === \"left\" ) { player . x -= 1 ; } else if ( message . command === \"right\" ) { player . x += 1 ; } console . log ( client . sessionId + \" at, x: \" + player . x , \"y: \" + player . y ); } }","title":"Example room"},{"location":"server/room/#public-properties","text":"","title":"Public properties"},{"location":"server/room/#roomid-string","text":"A unique, auto-generated, 9-character-long id of the room.","title":"roomId: string"},{"location":"server/room/#roomname-string","text":"The name of the room you provided as first argument for gameServer.define() .","title":"roomName: string"},{"location":"server/room/#state-t","text":"The state instance you provided to setState() .","title":"state: T"},{"location":"server/room/#clients-websocket","text":"The array of connected clients. See Web-Socket Client .","title":"clients: WebSocket[]"},{"location":"server/room/#maxclients-number","text":"Maximum number of clients allowed to connect into the room. When room reaches this limit, it is locked automatically. Unless the room was explicitly locked by you via lock() method, the room will be unlocked as soon as a client disconnects from it.","title":"maxClients: number"},{"location":"server/room/#patchrate-number","text":"Frequency to send the room state to connected clients, in milliseconds. Default is 50 ms (20fps)","title":"patchRate: number"},{"location":"server/room/#autodispose-boolean","text":"Automatically dispose the room when last client disconnect. Default is true","title":"autoDispose: boolean"},{"location":"server/room/#locked-boolean-read-only","text":"This property will change on these situations: The maximum number of allowed clients has been reached ( maxClients ) You manually locked, or unlocked the room using lock() or unlock() .","title":"locked: boolean (read-only)"},{"location":"server/room/#clock-clocktimer","text":"A ClockTimer instance, used for timing events .","title":"clock: ClockTimer"},{"location":"server/room/#presence-presence","text":"The presence instance. Check Presence API for more details.","title":"presence: Presence"},{"location":"server/room/#public-methods","text":"Room handlers have these methods available.","title":"Public methods"},{"location":"server/room/#setstate-object","text":"Set the new room state instance. See State Handling for more details on the state object. It's highly recommended to use the new Schema Serializer to handle your state. Warning Do not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it. Tip You usually will call this method only once during onCreate() in your room handler.","title":"setState (object)"},{"location":"server/room/#setsimulationinterval-callback-milliseconds166","text":"(Optional) Set a simulation interval that can change the state of the game. The simulation interval is your game loop. Default simulation interval: 16.6ms (60fps) onCreate () { this . setSimulationInterval (( deltaTime ) => this . update ( deltaTime )); } update ( deltaTime ) { // implement your physics or world updates here! // this is a good place to update the room state }","title":"setSimulationInterval (callback[, milliseconds=16.6])"},{"location":"server/room/#setpatchrate-milliseconds","text":"Set frequency the patched state should be sent to all clients. Default is 50ms (20fps)","title":"setPatchRate (milliseconds)"},{"location":"server/room/#setprivate-bool","text":"Set the room listing as private (or revert to public, if false is provided). Private rooms are not listed in the getAvailableRooms() method.","title":"setPrivate (bool)"},{"location":"server/room/#setmetadata-metadata","text":"Set metadata to this room. Each room instance may have metadata attached to it - the only purpose for attaching metadata is to differentiate one room from another when getting the list of available rooms from the client-side, to connect to it by its roomId , using client.getAvailableRooms() . // server-side this . setMetadata ({ friendlyFire : true }); Now that a room has metadata attached to it, the client-side can check which room has friendlyFire , for example, and connect directly to it via its roomId : // client-side client . getAvailableRooms ( \"battle\" ). then ( rooms => { for ( var i = 0 ; i < rooms . length ; i ++ ) { if ( room . metadata && room . metadata . friendlyFire ) { // // join the room with `friendlyFire` by id: // var room = client . join ( room . roomId ); return ; } } }); Tip See how to call getAvailableRooms() in other languages.","title":"setMetadata (metadata)"},{"location":"server/room/#setseatreservationtime-seconds","text":"Set the number of seconds a room can wait for a client to effectively join the room. You should consider how long your onAuth() will have to wait for setting a different seat reservation time. The default value is usually enough. (8 seconds)","title":"setSeatReservationTime (seconds)"},{"location":"server/room/#send-client-message","text":"Send a message to a particular client. The message can be either a plain JavaScript object, or a Schema instance. Sending a msgpack-encoded message: This is the recommended way if you're using an interpreted language on the client-side, such as JavaScript or LUA. this . send ( client , { message : \"Hello world!\" }); Sending a schema-encoded message: Sending schema-encoded messages is particularly useful for statically-typed languages such as C#. class MyMessage extends Schema { @type ( \"string\" ) message : string ; } const data = new MyMessage (); data . message = \"Hello world!\" ; this . send ( client , data ); Tip See how to handle these messages on client-side.","title":"send (client, message)"},{"location":"server/room/#broadcast-message-options","text":"Send a message to all connected clients. Available options are: except : a Client instance not to send the message to afterNextPatch : waits until next patch to broadcast the message","title":"broadcast (message, options?)"},{"location":"server/room/#broadcast-examples","text":"Broadcasting a message to all clients: onMessage ( client , message ) { if ( message === \"action\" ) { // broadcast a message to all clients this . broadcast ( \"an action has been taken!\" ); } } Broadcasting a message to all clients, except the sender. onMessage ( client , message ) { if ( message === \"fire\" ) { // sends \"fire\" event to every client, except the one who triggered it. this . broadcast ( \"fire!\" , { except : client }); } } Broadcasting a message to all clients, only after a change in the state has been applied: onMessage ( client , message ) { if ( message === \"destroy\" ) { // perform changes in your state! this . state . destroySomething (); // this message will arrive only after new state has been applied this . broadcast ( \"has been destroyed!\" , { afterNextPatch : true }); } } Broadcasting a schema-encoded message: class MyMessage extends Schema { @type ( \"string\" ) message : string ; } // ... onMessage ( client , message ) { if ( message === \"action\" ) { const data = new MyMessage (); data . message = \"an action has been taken!\" ; this . broadcast ( data ); } } Tip See how to handle these onMessage() in the client-side.","title":"Broadcast examples"},{"location":"server/room/#lock","text":"Locking the room will remove it from the pool of available rooms for new clients to connect to.","title":"lock ()"},{"location":"server/room/#unlock","text":"Unlocking the room returns it to the pool of available rooms for new clients to connect to.","title":"unlock ()"},{"location":"server/room/#allowreconnection-client-seconds","text":"Allow the specified client to reconnect into the room. Must be used inside onLeave() method. If seconds is provided, the reconnection is going to be cancelled after the provided amout of seconds. async onLeave ( client , consented : boolean ) { // flag client as inactive for other users this . state . players [ client . sessionId ]. connected = false ; try { if ( consented ) { throw new Error ( \"consented leave\" ); } // allow disconnected client to reconnect into this room until 20 seconds await this . allowReconnection ( client , 20 ); // client returned! let's re-activate it. this . state . players [ client . sessionId ]. connected = true ; } catch ( e ) { // 20 seconds expired. let's remove the client. delete this . state . players [ client . sessionId ]; } } Alternatively, you may not provide the amount of seconds to automatically reject the reconnection, and reject it yourself using your own logic. async onLeave ( client , consented : boolean ) { // flag client as inactive for other users this . state . players [ client . sessionId ]. connected = false ; try { if ( consented ) { throw new Error ( \"consented leave\" ); } // get reconnection token const reconnection = this . allowReconnection ( client ); // // here is the custom logic for rejecting the reconnection. // for demonstration purposes of the API, an interval is created // rejecting the reconnection if the player has missed 2 rounds, // (assuming he's playing a turn-based game) // // in a real scenario, you would store the `reconnection` in // your Player instance, for example, and perform this check during your // game loop logic // const currentRound = this . state . currentRound ; const interval = setInterval (() => { if (( this . state . currentRound - currentRound ) > 2 ) { // manually reject the client reconnection reconnection . reject (); clearInterval ( interval ); } }, 1000 ); // allow disconnected client to reconnect await reconnection ; // client returned! let's re-activate it. this . state . players [ client . sessionId ]. connected = true ; } catch ( e ) { // 20 seconds expired. let's remove the client. delete this . state . players [ client . sessionId ]; } }","title":"allowReconnection (client, seconds?)"},{"location":"server/room/#disconnect","text":"Disconnect all clients, then dispose.","title":"disconnect ()"},{"location":"server/state-serialization/","text":"Colyseus currently provides two serialization methods out of the box: Schema (default) Fossil Delta See below how to specify which serialization method to use. TypeScript import { serialize , FossilDeltaSerializer , Room } from \"colyseus\" ; @serialize ( FossilDeltaSerializer ) class MyRoom extends Room { // your room definition } JavaScript const colyseus = require ( 'colyseus' ); class MyRoom extends colyseus . Room { // your room definition } colyseus . serialize ( colyseus . FossilDeltaSerializer )( MyRoom ); Implementing a custom serializer (server-side) \u00b6 If you feel the need to implement a custom state serializer, you should be able to. \ud83d\udc7b You probably don't need this! \ud83d\udc7b If you're just starting out with the framework, read the \"State Handling\" pages instead. This feature is experimental You are likely to need to fork the client library you're working with to integrate the de-serializer in the client. In the future, all clients should support an API to set a custom de-serializer. At the time of this writing, only the JavaScript and Defold clients are able to register custom de-serializers. id: string \u00b6 Id of the serializer. The client-side can instantiate a custom serializer based on this id. reset(data): void \u00b6 Reset the state. getFullState(client): number[] \u00b6 The first state sent to the client upon joining the room. Must return a byte array. applyPatches(clients): number[] \u00b6 A subsequent patch to be sent for all clients, or particular client. Must return a byte array. handshake(clients): number[] \u00b6 Custom handshake data to be sent to the client upon joining the room. Must return a byte array. Implementing a custom de-serializer (client-side) \u00b6 Tip The de-serializer implementation varies accourding to the client library you're using. Feel free to ask for help in the forums or Discord . You're encouraged to take a look at the existing serializer's implementation to guide you write your own: JavaScript's FossilDeltaSerializer Defold Engine's FossilDeltaSerializer setState(data): void \u00b6 Set the state instance. getState(): any \u00b6 The the state instance. patch(bytes: number[]): void \u00b6 Receive the patches coming from the server. teardown(): void \u00b6 Clean-up what needs to be cleared when leaving the room. handshake(bytes: number): void \u00b6 Receive the handshake sent by the server upon joining the room. Registering the de-serializer in the client-side \u00b6 TypeScript import { registerSerializer , Serializer } from \"colyseus.js\" ; class MyOwnSerializer extends Serializer { // ... // your de-serializer implementation // ... } registerSerializer ( 'my-own-serializer' , MyOwnSerializer ); Defold / LUA local ColyseusSerializer = require ( 'colyseus.serialization' ) local my_own_serializer = {} my_own_serializer . __index = my_own_serializer function my_own_serializer . new () local instance = {} setmetatable ( instance , my_own_serializer ) return instance end -- ... -- your de-serializer implementation -- ... ColyseusSerializer . register_serializer ( 'my-own-serializer' , my_own_serializer )","title":"Custom State Serialization"},{"location":"server/state-serialization/#implementing-a-custom-serializer-server-side","text":"If you feel the need to implement a custom state serializer, you should be able to. \ud83d\udc7b You probably don't need this! \ud83d\udc7b If you're just starting out with the framework, read the \"State Handling\" pages instead. This feature is experimental You are likely to need to fork the client library you're working with to integrate the de-serializer in the client. In the future, all clients should support an API to set a custom de-serializer. At the time of this writing, only the JavaScript and Defold clients are able to register custom de-serializers.","title":"Implementing a custom serializer (server-side)"},{"location":"server/state-serialization/#id-string","text":"Id of the serializer. The client-side can instantiate a custom serializer based on this id.","title":"id: string"},{"location":"server/state-serialization/#resetdata-void","text":"Reset the state.","title":"reset(data): void"},{"location":"server/state-serialization/#getfullstateclient-number","text":"The first state sent to the client upon joining the room. Must return a byte array.","title":"getFullState(client): number[]"},{"location":"server/state-serialization/#applypatchesclients-number","text":"A subsequent patch to be sent for all clients, or particular client. Must return a byte array.","title":"applyPatches(clients): number[]"},{"location":"server/state-serialization/#handshakeclients-number","text":"Custom handshake data to be sent to the client upon joining the room. Must return a byte array.","title":"handshake(clients): number[]"},{"location":"server/state-serialization/#implementing-a-custom-de-serializer-client-side","text":"Tip The de-serializer implementation varies accourding to the client library you're using. Feel free to ask for help in the forums or Discord . You're encouraged to take a look at the existing serializer's implementation to guide you write your own: JavaScript's FossilDeltaSerializer Defold Engine's FossilDeltaSerializer","title":"Implementing a custom de-serializer (client-side)"},{"location":"server/state-serialization/#setstatedata-void","text":"Set the state instance.","title":"setState(data): void"},{"location":"server/state-serialization/#getstate-any","text":"The the state instance.","title":"getState(): any"},{"location":"server/state-serialization/#patchbytes-number-void","text":"Receive the patches coming from the server.","title":"patch(bytes: number[]): void"},{"location":"server/state-serialization/#teardown-void","text":"Clean-up what needs to be cleared when leaving the room.","title":"teardown(): void"},{"location":"server/state-serialization/#handshakebytes-number-void","text":"Receive the handshake sent by the server upon joining the room.","title":"handshake(bytes: number): void"},{"location":"server/state-serialization/#registering-the-de-serializer-in-the-client-side","text":"TypeScript import { registerSerializer , Serializer } from \"colyseus.js\" ; class MyOwnSerializer extends Serializer { // ... // your de-serializer implementation // ... } registerSerializer ( 'my-own-serializer' , MyOwnSerializer ); Defold / LUA local ColyseusSerializer = require ( 'colyseus.serialization' ) local my_own_serializer = {} my_own_serializer . __index = my_own_serializer function my_own_serializer . new () local instance = {} setmetatable ( instance , my_own_serializer ) return instance end -- ... -- your de-serializer implementation -- ... ColyseusSerializer . register_serializer ( 'my-own-serializer' , my_own_serializer )","title":"Registering the de-serializer in the client-side"},{"location":"server/timing-events/","text":"For timing events , it's recommended to use the this.clock methods, from your Room instance. Tip All intervals and timeouts registered on this.clock are cleared automatically when the Room is disposed. Important The built-in setTimeout and setInterval methods rely on CPU load, which may delay an unexpected amount of time to execute. Clock \u00b6 The clock is provided as a useful mechanism to time events outside of a stateful simulation. An example use case could be: when a player collects an item you might clock.setTimeout to create a new collectible. One advantage to using clock. is that you do not have to be concerned with room updates and deltas and can instead focus on timing your events independently of the room state. Public methods \u00b6 Note: time parameters are in milliseconds clock.setInterval(callback, time, ...args): Delayed \u00b6 The setInterval() method repeatedly calls a function or executes a code snippet, with a fixed time delay between each call. It returns Delayed instance which identifies the interval, so you can manipulate it later. clock.setTimeout(callback, time, ...args): Delayed \u00b6 The setTimeout() method sets a timer which executes a function or specified piece of code once after the timer expires. It returns Delayed instance which identifies the interval, so you can manipulate it later. Example This MVP example shows a Room with: setInterval() , setTimeout and clearing a previously stored instance of type Delayed ; along with showing the currentTime from the Room's clock instance. After 1 second 'Time now ' + this.clock.currentTime is console.log 'd, and then after 10 seconds we clear the interval: this.delayedInterval.clear(); . // Import Delayed import { Room , Client , Delayed } from \"colyseus\" ; export class MyRoom extends Room { // For this example public delayedInterval !: Delayed ; // When room is initialized onCreate ( options : any ) { // start the clock ticking this . clock . start (); // Set an interval and store a reference to it // so that we may clear it later this . delayedInterval = this . clock . setInterval (() => { console . log ( \"Time now \" + this . clock . currentTime ); }, 1000 ); // After 10 seconds clear the timeout; // this will *stop and destroy* the timeout completely this . clock . setTimeout (() => { this . delayedInterval . clear (); }, 10 _000 ); } onMessage() { } } clock.clear() \u00b6 Clear all intervals and timeouts registered with clock.setInterval() and clock.setTimeout() . clock.start() \u00b6 Start counting time. clock.stop() \u00b6 Stop counting time. clock.tick() \u00b6 This method is called automatically at every simulation interval step. All Delayed instances are checked during tick . Tip See Room#setSimiulationInterval() for more details. Public properties \u00b6 clock.elapsedTime \u00b6 Elapsed time in milliseconds since clock.start() method was called. Read only. clock.currentTime \u00b6 Current time in milliseconds. Read only. clock.deltaTime \u00b6 The difference in milliseconds between the last and current clock.tick() call. Read only. Delayed \u00b6 Delayed instances are created from clock.setInterval() or clock.setTimeout() methods. Public methods \u00b6 delayed.clear() \u00b6 Clears the timeout or interval. delayed.reset() \u00b6 Reset the elapsed time. Public properties \u00b6 delayed.active: boolean \u00b6 Returns true if timer is still running.","title":"Timing events"},{"location":"server/timing-events/#clock","text":"The clock is provided as a useful mechanism to time events outside of a stateful simulation. An example use case could be: when a player collects an item you might clock.setTimeout to create a new collectible. One advantage to using clock. is that you do not have to be concerned with room updates and deltas and can instead focus on timing your events independently of the room state.","title":"Clock"},{"location":"server/timing-events/#public-methods","text":"Note: time parameters are in milliseconds","title":"Public methods"},{"location":"server/timing-events/#clocksetintervalcallback-time-args-delayed","text":"The setInterval() method repeatedly calls a function or executes a code snippet, with a fixed time delay between each call. It returns Delayed instance which identifies the interval, so you can manipulate it later.","title":"clock.setInterval(callback, time, ...args): Delayed"},{"location":"server/timing-events/#clocksettimeoutcallback-time-args-delayed","text":"The setTimeout() method sets a timer which executes a function or specified piece of code once after the timer expires. It returns Delayed instance which identifies the interval, so you can manipulate it later. Example This MVP example shows a Room with: setInterval() , setTimeout and clearing a previously stored instance of type Delayed ; along with showing the currentTime from the Room's clock instance. After 1 second 'Time now ' + this.clock.currentTime is console.log 'd, and then after 10 seconds we clear the interval: this.delayedInterval.clear(); . // Import Delayed import { Room , Client , Delayed } from \"colyseus\" ; export class MyRoom extends Room { // For this example public delayedInterval !: Delayed ; // When room is initialized onCreate ( options : any ) { // start the clock ticking this . clock . start (); // Set an interval and store a reference to it // so that we may clear it later this . delayedInterval = this . clock . setInterval (() => { console . log ( \"Time now \" + this . clock . currentTime ); }, 1000 ); // After 10 seconds clear the timeout; // this will *stop and destroy* the timeout completely this . clock . setTimeout (() => { this . delayedInterval . clear (); }, 10 _000 ); } onMessage() { } }","title":"clock.setTimeout(callback, time, ...args): Delayed"},{"location":"server/timing-events/#clockclear","text":"Clear all intervals and timeouts registered with clock.setInterval() and clock.setTimeout() .","title":"clock.clear()"},{"location":"server/timing-events/#clockstart","text":"Start counting time.","title":"clock.start()"},{"location":"server/timing-events/#clockstop","text":"Stop counting time.","title":"clock.stop()"},{"location":"server/timing-events/#clocktick","text":"This method is called automatically at every simulation interval step. All Delayed instances are checked during tick . Tip See Room#setSimiulationInterval() for more details.","title":"clock.tick()"},{"location":"server/timing-events/#public-properties","text":"","title":"Public properties"},{"location":"server/timing-events/#clockelapsedtime","text":"Elapsed time in milliseconds since clock.start() method was called. Read only.","title":"clock.elapsedTime"},{"location":"server/timing-events/#clockcurrenttime","text":"Current time in milliseconds. Read only.","title":"clock.currentTime"},{"location":"server/timing-events/#clockdeltatime","text":"The difference in milliseconds between the last and current clock.tick() call. Read only.","title":"clock.deltaTime"},{"location":"server/timing-events/#delayed","text":"Delayed instances are created from clock.setInterval() or clock.setTimeout() methods.","title":"Delayed"},{"location":"server/timing-events/#public-methods_1","text":"","title":"Public methods"},{"location":"server/timing-events/#delayedclear","text":"Clears the timeout or interval.","title":"delayed.clear()"},{"location":"server/timing-events/#delayedreset","text":"Reset the elapsed time.","title":"delayed.reset()"},{"location":"server/timing-events/#public-properties_1","text":"","title":"Public properties"},{"location":"server/timing-events/#delayedactive-boolean","text":"Returns true if timer is still running.","title":"delayed.active: boolean"},{"location":"state/fossil-delta/","text":"State Handling \u00bb Fossil Delta \u00b6 FossilDelta is going to be deprecated on future versions of Colyseus. Make sure to use the Schema Serializer . \u00b6 The FossilDeltaSerializer is permissive about which structure you provide as the state. You may provide a raw object, or a class instance. All the enumerable properties of the object provided are going to be serialized to the clients. Non-synchronizable properties should be non-enumerable (through @nosync ) You may white-list synchronizable propertires through toJSON() method. Server-side \u00b6 Raw Object State \u00b6 The simplest way to deal with the room state is using a raw JavaScript objects directly in the Room handler. On the following example, you'll see: Creating player upon client connection. Handling client-side actions and updating the state to move x position. Removing player upon client disconnection. TypeScript import { Room , Client } from \"colyseus\" ; export class BattleRoom extends Room { onCreate ( options : any ) { this . setState ({ players : {} }); } onJoin ( client ) { this . state . players [ client . sessionId ] = { x : 0 , y : 0 }; } onLeave ( client ) { delete this . state . players [ client . sessionId ]; } onMessage ( client , data ) { if ( data . action === \"left\" ) { this . state . players [ client . sessionId ]. x -= 1 ; } else if ( data . action === \"right\" ) { this . state . players [ client . sessionId ]. x += 1 ; } } } JavaScript const colyseus = require ( 'colyseus' ) export class BattleRoom extends colyseus . Room { onCreate ( options : any ) { this . setState ({ players : {} }); } onJoin ( client ) { this . state . players [ client . sessionId ] = { x : 0 , y : 0 }; } onLeave ( client ) { delete this . state . players [ client . sessionId ]; } onMessage ( client , data ) { if ( data . action === \"left\" ) { this . state . players [ client . sessionId ]. x -= 1 ; } else if ( data . action === \"right\" ) { this . state . players [ client . sessionId ]. x += 1 ; } } } Your Own Data Structures \u00b6 Whilst it's possible to use raw data directly on this.setState() . The recommended way to handle your state is through your own data structures. On the following (rewritten) example, you'll see: A clean BattleRoom implementation, directly coupled to the state structure. A large data structure holding the entire room state ( BattleState ) Methods manipulating smaller data structures A small decoupled data structure representing a single entity ( Player ) TypeScript import { Room , Client } from \"colyseus\" ; class Player { x : number ; y : number ; } class BattleState { players : {[ id : string ] : Player } = {}; addPlayer ( client ) { this . players [ client . sessionId ] = new Player ( 0 , 0 ); } removePlayer ( client ) { delete this . players [ client . sessionId ]; } movePlayer ( client , action ) { if ( action === \"left\" ) { this . players [ client . sessionId ]. x -= 1 ; } else if ( action === \"right\" ) { this . players [ client . sessionId ]. x += 1 ; } } } export class BattleRoom extends Room < BattleState > { onCreate ( options : any ) { this . setState ( new BattleState ()); } onJoin ( client : Client ) { this . state . addPlayer ( client ); } onLeave ( client : Client ) { this . state . removePlayer ( client ); } onMessage ( client : Client , data : any ) { if ( data . action ) { this . state . movePlayer ( client , data . action ); } } } JavaScript const colyseus = require ( 'colyseus' ); class Player { constructor ( x , y ) { this . x = x ; this . y = y ; } } class BattleState { constructor () { this . players = {}; } addPlayer ( client ) { this . players [ client . sessionId ] = new Player ( 0 , 0 ); } removePlayer ( client ) { delete this . players [ client . sessionId ]; } movePlayer ( client , action ) { if ( action === \"left\" ) { this . players [ client . sessionId ]. x -= 1 ; } else if ( action === \"right\" ) { this . players [ client . sessionId ]. x += 1 ; } } } module .exports = class BattleRoom extends colyseus . Room { onCreate ( options : any ) { this . setState ( new BattleState ()); } onJoin ( client ) { this . state . addPlayer ( client ); } onLeave ( client ) { this . state . removePlayer ( client ); } onMessage ( client , data ) { if ( data . action ) { this . state . movePlayer ( client , data . action ); } } } Non-synchronizable properties ( @nosync ) \u00b6 To prevent private properties from leaking into your clients' state, you need to set those properties as non-enumerable . The decorator @nosync is a syntax sugar for this purpose. TypeScript import { nosync } from \"colyseus\" ; export class Player { x : number = 0 ; y : number = 0 ; @nosync wontBeSynched : string = \"This property won't be synched with clients\" ; } JavaScript const colyseus = require ( 'colyseus' ); module .exports = class Player { constructor () { this . x = 0 ; this . y = 0 ; this . wontBeSynched = \"This property won't be synched with clients\" ; } } colyseus . nosync ( Player . prototype , \"wontBeSynched\" ); White-listing synchronizable properties thorugh toJSON() \u00b6 In your data structures, you may implement a toJSON() method, to explicitly define how it should be serialized for the clients. This way, you don't need to use nosync , since you're white-listing the properties manually. TypeScript export class Player { x : number = 0 ; y : number = 0 ; complexObject = new SomethingElse (); toJSON () { return { x : this.x , y : this.y , } } } JavaScript module .exports = class Player { constructor ( x , y ) { this . x = x ; this . y = y ; this . complexObject = new SomethingElse (); } toJSON () { return { x : this.x , y : this.y , } } } Limitations \u00b6 Avoid using Map , Set \u00b6 Avoid using Map and Set for public, synchronizeable, properties. Unfortunately, the JavaScript built-in types Map and Set aren't serializeable. That's because their internal structure is not exposed as enumerable properties: var myMap = new Map ([[ \"k1\" , \"v1\" ], [ \"k2\" , \"v2\" ]]); // => Map(2) {\"key\" => \"value\", \"key2\" => \"value2\"} JSON . stringify ( myMap ); // => \"{}\" You're encouraged to use these structures as private, non-synchronizable variables, though. See @nosync . Avoid mutating arrays \u00b6 push ing new entries is OK - the clients will receive a single \"add\" operation. pop ing the last entry is OK - the clients will receive a single \"remove\" operation. Removing or inserting entries in-between will generate one \"replace\" operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly. Client-side \u00b6 Listening for changes in a particular variable. \u00b6 The example below describes how to listen for a particular variable. You may use the full path of a known variable, such as \"a/really/deep/path\" , \"world/fog\" , etc. JavaScript room . listen ( \"currentTurn\" , ( change ) => { console . log ( \"current turn is now\" , change . value ); }) C# using Colyseus ; // ... room . Listen ( \"currentTurn\" , OnCurrentTurnChange ); void OnCurrentTurnChange ( DataChange change ) { Debug . Log ( \"current turn is now:\" ); Debug . Log ( change . value ); }); lua room : listen ( \"currentTurn\" , function ( change ) print ( \"current turn is now: \" .. change . value ); end ) Haxe room . listen ( \"currentTurn\" , function ( change ) { trace ( \"current turn is now: \" + change . value ); }); Listening to map data structures \u00b6 The example below describes how to catch addition and removals of a map. The callback will be called multiple times, for each entry added or removed from a map of players. This example do not listen for changes inside each player instance. To listen for changes inside each player instance, you should listen for \"players/:id/:attribute\" path as well . JavaScript room . listen ( \"players/:id\" , ( change ) => { if ( change . operation === \"add\" ) { console . log ( \"new player added to the state\" ); console . log ( \"player id:\" , change . path . id ); console . log ( \"player data:\" , change . value ); } else if ( change . operation === \"remove\" ) { console . log ( \"player has been removed from the state\" ); console . log ( \"player id:\" , change . path . id ); } }); C# using Colyseus ; // ... room . Listen ( \"players/:id\" , OnPlayerChange ); void OnPlayerChange ( DataChange change ) { if ( change . operation == \"add\" ) { Debug . Log ( \"new player added to the state\" ); Debug . Log ( change . path [ \"id\" ]); Debug . Log ( change . value ); } else if ( change . operation == \"remove\" ) { Debug . Log ( \"player has been removed from the state\" ); Debug . Log ( change . path [ \"id\" ]); } }); lua room : listen ( \"players/:id\" , function ( change ) if ( change . operation == \"add\" ) then print ( \"new player added to the state\" ) print ( change . path [ \"id\" ]) print ( change . value ) elseif ( change . operation == \"remove\" ) then print ( \"player has been removed from the state\" ) print ( change . path [ \"id\" ]) end end ) Haxe room . listen ( \"players/:id\" , function ( change ) { if ( change . operation == = \"add\" ) { trace ( \"new player added to the state\" ); trace ( \"player id:\" + change . path . id ); trace ( \"player data:\" + Std . string ( change . value )); } else if ( change . operation == = \"remove\" ) { trace ( \"player has been removed from the state\" ); trace ( \"player id:\" + change . path . id ); } }); Listening to attribute changes of deep data structures \u00b6 The example below describes how to catch each attribute change from inside a map of players. The callback will be called multiple times, for each attribute that has changed. JavaScript room . listen ( \"players/:id/:attribute\" , ( change ) => { console . log ( change . operation ); // => \"add\" | \"remove\" | \"replace\" console . log ( change . path . attribute , \"has been changed\" ); console . log ( change . path . id ); console . log ( change . value ); }); C# using Colyseus ; // ... room . Listen ( \"players/:id/:attribute\" , OnPlayerAttributeChange ); void OnPlayerAttributeChange ( DataChange change ) { Debug . Log ( change . operation ); // => \"add\" | \"remove\" | \"replace\" Debug . Log ( change . path [ \"attribute\" ] + \"has been changed\" ); Debug . Log ( change . path [ \"id\" ]); Debug . Log ( change . value ); }); lua room : listen ( \"players/:id/:attribute\" , function () print ( change . operation ) // => \"add\" | \"remove\" | \"replace\" print ( change . path [ \"attribute\" ] + \"has been changed\" ) print ( change . path [ \"id\" ]) print ( change . value ) end ) Haxe room . listen ( \"players/:id/:attribute\" , function ( change ) { trace ( change . operation ); // => \"add\" | \"remove\" | \"replace\" trace ( change . path . attribute + \" has been changed\" ); trace ( change . path . id ); trace ( Std . string ( change . value )); }); Initial state / Listening to incoming AND existing data in the state \u00b6 The callbacks will be triggered for each incoming change in the state after the moment of registration. To listen also for existing data on the state at the moment you register the callback, make sure to pass true on the immediate argument. JavaScript room . listen ( \"players/:id\" , ( change ) => { // ... }, true ); // immediate C# using Colyseus ; // ... room . Listen ( \"players/:id\" , OnPlayerChange , true ); // immediate void OnPlayerChange ( DataChange change ) { // ... }); lua room : listen ( \"players/:id\" , function ( change ) -- ... end , true ) -- immediate Haxe room . listen ( \"players/:id\" , function ( change ) { // ... }, true ); // immediate","title":"Fossil Delta (deprecated)"},{"location":"state/fossil-delta/#state-handling-fossil-delta","text":"","title":"State Handling \u00bb Fossil Delta"},{"location":"state/fossil-delta/#fossildelta-is-going-to-be-deprecated-on-future-versions-of-colyseus-make-sure-to-use-the-schema-serializer","text":"The FossilDeltaSerializer is permissive about which structure you provide as the state. You may provide a raw object, or a class instance. All the enumerable properties of the object provided are going to be serialized to the clients. Non-synchronizable properties should be non-enumerable (through @nosync ) You may white-list synchronizable propertires through toJSON() method.","title":"FossilDelta is going to be deprecated on future versions of Colyseus. Make sure to use the Schema Serializer."},{"location":"state/fossil-delta/#server-side","text":"","title":"Server-side"},{"location":"state/fossil-delta/#raw-object-state","text":"The simplest way to deal with the room state is using a raw JavaScript objects directly in the Room handler. On the following example, you'll see: Creating player upon client connection. Handling client-side actions and updating the state to move x position. Removing player upon client disconnection. TypeScript import { Room , Client } from \"colyseus\" ; export class BattleRoom extends Room { onCreate ( options : any ) { this . setState ({ players : {} }); } onJoin ( client ) { this . state . players [ client . sessionId ] = { x : 0 , y : 0 }; } onLeave ( client ) { delete this . state . players [ client . sessionId ]; } onMessage ( client , data ) { if ( data . action === \"left\" ) { this . state . players [ client . sessionId ]. x -= 1 ; } else if ( data . action === \"right\" ) { this . state . players [ client . sessionId ]. x += 1 ; } } } JavaScript const colyseus = require ( 'colyseus' ) export class BattleRoom extends colyseus . Room { onCreate ( options : any ) { this . setState ({ players : {} }); } onJoin ( client ) { this . state . players [ client . sessionId ] = { x : 0 , y : 0 }; } onLeave ( client ) { delete this . state . players [ client . sessionId ]; } onMessage ( client , data ) { if ( data . action === \"left\" ) { this . state . players [ client . sessionId ]. x -= 1 ; } else if ( data . action === \"right\" ) { this . state . players [ client . sessionId ]. x += 1 ; } } }","title":"Raw Object State"},{"location":"state/fossil-delta/#your-own-data-structures","text":"Whilst it's possible to use raw data directly on this.setState() . The recommended way to handle your state is through your own data structures. On the following (rewritten) example, you'll see: A clean BattleRoom implementation, directly coupled to the state structure. A large data structure holding the entire room state ( BattleState ) Methods manipulating smaller data structures A small decoupled data structure representing a single entity ( Player ) TypeScript import { Room , Client } from \"colyseus\" ; class Player { x : number ; y : number ; } class BattleState { players : {[ id : string ] : Player } = {}; addPlayer ( client ) { this . players [ client . sessionId ] = new Player ( 0 , 0 ); } removePlayer ( client ) { delete this . players [ client . sessionId ]; } movePlayer ( client , action ) { if ( action === \"left\" ) { this . players [ client . sessionId ]. x -= 1 ; } else if ( action === \"right\" ) { this . players [ client . sessionId ]. x += 1 ; } } } export class BattleRoom extends Room < BattleState > { onCreate ( options : any ) { this . setState ( new BattleState ()); } onJoin ( client : Client ) { this . state . addPlayer ( client ); } onLeave ( client : Client ) { this . state . removePlayer ( client ); } onMessage ( client : Client , data : any ) { if ( data . action ) { this . state . movePlayer ( client , data . action ); } } } JavaScript const colyseus = require ( 'colyseus' ); class Player { constructor ( x , y ) { this . x = x ; this . y = y ; } } class BattleState { constructor () { this . players = {}; } addPlayer ( client ) { this . players [ client . sessionId ] = new Player ( 0 , 0 ); } removePlayer ( client ) { delete this . players [ client . sessionId ]; } movePlayer ( client , action ) { if ( action === \"left\" ) { this . players [ client . sessionId ]. x -= 1 ; } else if ( action === \"right\" ) { this . players [ client . sessionId ]. x += 1 ; } } } module .exports = class BattleRoom extends colyseus . Room { onCreate ( options : any ) { this . setState ( new BattleState ()); } onJoin ( client ) { this . state . addPlayer ( client ); } onLeave ( client ) { this . state . removePlayer ( client ); } onMessage ( client , data ) { if ( data . action ) { this . state . movePlayer ( client , data . action ); } } }","title":"Your Own Data Structures"},{"location":"state/fossil-delta/#non-synchronizable-properties-nosync","text":"To prevent private properties from leaking into your clients' state, you need to set those properties as non-enumerable . The decorator @nosync is a syntax sugar for this purpose. TypeScript import { nosync } from \"colyseus\" ; export class Player { x : number = 0 ; y : number = 0 ; @nosync wontBeSynched : string = \"This property won't be synched with clients\" ; } JavaScript const colyseus = require ( 'colyseus' ); module .exports = class Player { constructor () { this . x = 0 ; this . y = 0 ; this . wontBeSynched = \"This property won't be synched with clients\" ; } } colyseus . nosync ( Player . prototype , \"wontBeSynched\" );","title":"Non-synchronizable properties (@nosync)"},{"location":"state/fossil-delta/#white-listing-synchronizable-properties-thorugh-tojson","text":"In your data structures, you may implement a toJSON() method, to explicitly define how it should be serialized for the clients. This way, you don't need to use nosync , since you're white-listing the properties manually. TypeScript export class Player { x : number = 0 ; y : number = 0 ; complexObject = new SomethingElse (); toJSON () { return { x : this.x , y : this.y , } } } JavaScript module .exports = class Player { constructor ( x , y ) { this . x = x ; this . y = y ; this . complexObject = new SomethingElse (); } toJSON () { return { x : this.x , y : this.y , } } }","title":"White-listing synchronizable properties thorugh toJSON()"},{"location":"state/fossil-delta/#limitations","text":"","title":"Limitations"},{"location":"state/fossil-delta/#avoid-using-map-set","text":"Avoid using Map and Set for public, synchronizeable, properties. Unfortunately, the JavaScript built-in types Map and Set aren't serializeable. That's because their internal structure is not exposed as enumerable properties: var myMap = new Map ([[ \"k1\" , \"v1\" ], [ \"k2\" , \"v2\" ]]); // => Map(2) {\"key\" => \"value\", \"key2\" => \"value2\"} JSON . stringify ( myMap ); // => \"{}\" You're encouraged to use these structures as private, non-synchronizable variables, though. See @nosync .","title":"Avoid using Map, Set"},{"location":"state/fossil-delta/#avoid-mutating-arrays","text":"push ing new entries is OK - the clients will receive a single \"add\" operation. pop ing the last entry is OK - the clients will receive a single \"remove\" operation. Removing or inserting entries in-between will generate one \"replace\" operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly.","title":"Avoid mutating arrays"},{"location":"state/fossil-delta/#client-side","text":"","title":"Client-side"},{"location":"state/fossil-delta/#listening-for-changes-in-a-particular-variable","text":"The example below describes how to listen for a particular variable. You may use the full path of a known variable, such as \"a/really/deep/path\" , \"world/fog\" , etc. JavaScript room . listen ( \"currentTurn\" , ( change ) => { console . log ( \"current turn is now\" , change . value ); }) C# using Colyseus ; // ... room . Listen ( \"currentTurn\" , OnCurrentTurnChange ); void OnCurrentTurnChange ( DataChange change ) { Debug . Log ( \"current turn is now:\" ); Debug . Log ( change . value ); }); lua room : listen ( \"currentTurn\" , function ( change ) print ( \"current turn is now: \" .. change . value ); end ) Haxe room . listen ( \"currentTurn\" , function ( change ) { trace ( \"current turn is now: \" + change . value ); });","title":"Listening for changes in a particular variable."},{"location":"state/fossil-delta/#listening-to-map-data-structures","text":"The example below describes how to catch addition and removals of a map. The callback will be called multiple times, for each entry added or removed from a map of players. This example do not listen for changes inside each player instance. To listen for changes inside each player instance, you should listen for \"players/:id/:attribute\" path as well . JavaScript room . listen ( \"players/:id\" , ( change ) => { if ( change . operation === \"add\" ) { console . log ( \"new player added to the state\" ); console . log ( \"player id:\" , change . path . id ); console . log ( \"player data:\" , change . value ); } else if ( change . operation === \"remove\" ) { console . log ( \"player has been removed from the state\" ); console . log ( \"player id:\" , change . path . id ); } }); C# using Colyseus ; // ... room . Listen ( \"players/:id\" , OnPlayerChange ); void OnPlayerChange ( DataChange change ) { if ( change . operation == \"add\" ) { Debug . Log ( \"new player added to the state\" ); Debug . Log ( change . path [ \"id\" ]); Debug . Log ( change . value ); } else if ( change . operation == \"remove\" ) { Debug . Log ( \"player has been removed from the state\" ); Debug . Log ( change . path [ \"id\" ]); } }); lua room : listen ( \"players/:id\" , function ( change ) if ( change . operation == \"add\" ) then print ( \"new player added to the state\" ) print ( change . path [ \"id\" ]) print ( change . value ) elseif ( change . operation == \"remove\" ) then print ( \"player has been removed from the state\" ) print ( change . path [ \"id\" ]) end end ) Haxe room . listen ( \"players/:id\" , function ( change ) { if ( change . operation == = \"add\" ) { trace ( \"new player added to the state\" ); trace ( \"player id:\" + change . path . id ); trace ( \"player data:\" + Std . string ( change . value )); } else if ( change . operation == = \"remove\" ) { trace ( \"player has been removed from the state\" ); trace ( \"player id:\" + change . path . id ); } });","title":"Listening to map data structures"},{"location":"state/fossil-delta/#listening-to-attribute-changes-of-deep-data-structures","text":"The example below describes how to catch each attribute change from inside a map of players. The callback will be called multiple times, for each attribute that has changed. JavaScript room . listen ( \"players/:id/:attribute\" , ( change ) => { console . log ( change . operation ); // => \"add\" | \"remove\" | \"replace\" console . log ( change . path . attribute , \"has been changed\" ); console . log ( change . path . id ); console . log ( change . value ); }); C# using Colyseus ; // ... room . Listen ( \"players/:id/:attribute\" , OnPlayerAttributeChange ); void OnPlayerAttributeChange ( DataChange change ) { Debug . Log ( change . operation ); // => \"add\" | \"remove\" | \"replace\" Debug . Log ( change . path [ \"attribute\" ] + \"has been changed\" ); Debug . Log ( change . path [ \"id\" ]); Debug . Log ( change . value ); }); lua room : listen ( \"players/:id/:attribute\" , function () print ( change . operation ) // => \"add\" | \"remove\" | \"replace\" print ( change . path [ \"attribute\" ] + \"has been changed\" ) print ( change . path [ \"id\" ]) print ( change . value ) end ) Haxe room . listen ( \"players/:id/:attribute\" , function ( change ) { trace ( change . operation ); // => \"add\" | \"remove\" | \"replace\" trace ( change . path . attribute + \" has been changed\" ); trace ( change . path . id ); trace ( Std . string ( change . value )); });","title":"Listening to attribute changes of deep data structures"},{"location":"state/fossil-delta/#initial-state-listening-to-incoming-and-existing-data-in-the-state","text":"The callbacks will be triggered for each incoming change in the state after the moment of registration. To listen also for existing data on the state at the moment you register the callback, make sure to pass true on the immediate argument. JavaScript room . listen ( \"players/:id\" , ( change ) => { // ... }, true ); // immediate C# using Colyseus ; // ... room . Listen ( \"players/:id\" , OnPlayerChange , true ); // immediate void OnPlayerChange ( DataChange change ) { // ... }); lua room : listen ( \"players/:id\" , function ( change ) -- ... end , true ) -- immediate Haxe room . listen ( \"players/:id\" , function ( change ) { // ... }, true ); // immediate","title":"Initial state / Listening to incoming AND existing data in the state"},{"location":"state/overview/","text":"State Handling \u00b6 The room handlers are stateful in Colyseus. Each room holds its own state. The mutations of the state are synchronized automatically to all connected clients. Serialization methods \u00b6 Schema (default) Fossil Delta (deprecated) When the state is synchronized \u00b6 When the user successfully joins the room, he receives the full state from the server. At every patchRate , binary patches of the state are sent to every client (default is 50ms ) onStateChange is called in the client-side after every patch received from the server. Each serialization method has it's own particular way to handle incoming state patches.","title":"Overview"},{"location":"state/overview/#state-handling","text":"The room handlers are stateful in Colyseus. Each room holds its own state. The mutations of the state are synchronized automatically to all connected clients.","title":"State Handling"},{"location":"state/overview/#serialization-methods","text":"Schema (default) Fossil Delta (deprecated)","title":"Serialization methods"},{"location":"state/overview/#when-the-state-is-synchronized","text":"When the user successfully joins the room, he receives the full state from the server. At every patchRate , binary patches of the state are sent to every client (default is 50ms ) onStateChange is called in the client-side after every patch received from the server. Each serialization method has it's own particular way to handle incoming state patches.","title":"When the state is synchronized"},{"location":"state/schema/","text":"State Handling \u00bb Schema \u00b6 The SchemaSerializer has been introduced since Colyseus 0.10, and it's the default serialization method. The Schema strutures are meant to be used only for the room's state (synchronizeable data). You do not need to use Schema and its other structures for data that's part of your algorithms that aren't synchronizeable. Server-side \u00b6 To use the SchemaSerializer , you must: Have a state class extending the Schema class Annotate all your synchonizable properties with the @type() decorator Instantiate the state for your room ( this.setState(new MyState()) ) Are you not using TypeScript? Decorators are not part of ECMAScript yet , so the type syntax on plain JavaScript is still a bit odd to use, which you can see in the \"JavaScript\" tab for each snippet. TypeScript import { Schema , type } from \"@colyseus/schema\" ; class MyState extends Schema { @type ( \"string\" ) currentTurn : string ; } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; class MyState extends Schema { } schema . defineTypes ( MyState , { currentTurn : \"string\" }); Custom child data type \u00b6 You may define more custom data types inside your \"root\" state definition, as a direct reference, map, or array. TypeScript import { Schema , type } from \"@colyseus/schema\" ; class World extends Schema { @type ( \"number\" ) width : number ; @type ( \"number\" ) height : number ; @type ( \"number\" ) items : number = 10 ; } class MyState extends Schema { @type ( World ) world : World = new World (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; class World extends Schema { } schema . defineTypes ( World , { width : \"number\" , height : \"number\" , items : \"number\" }); class MyState extends Schema { constructor () { super (); this . world = new World (); } } schema . defineTypes ( MyState , { world : World }); Array of custom data type \u00b6 When using arrays within State related schema it's important to use the ArraySchema type. Do not use plain arrays inside your State classes (those which extend Schema ). Using plain arrays inside your methods is ok for game logic or otherwise; but not for syncronised state members. ArraySchema is recommended for describing the world map, or any collection in your game. They have all the methods available in an Array , but it's synchronizable. TypeScript import { Schema , ArraySchema , type } from \"@colyseus/schema\" ; class Block extends Schema { @type ( \"number\" ) x : number ; @type ( \"number\" ) y : number ; } class MyState extends Schema { @type ([ Block ]) blocks = new ArraySchema < Block > (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; const ArraySchema = schema . ArraySchema ; class Block extends Schema { } schema . defineTypes ( Block , { x : \"number\" , y : \"number\" }); class MyState extends Schema { constructor () { super (); this . blocks = new ArraySchema (); } } schema . defineTypes ( MyState , { blocks : [ Block ], }); Map of custom data type \u00b6 When using a map, it's important to use the MapSchema type. Do not use a plain object or the native Map type. MapSchema is recommended to track your game entities by id, such as players, enemies, etc. TypeScript import { Schema , MapSchema , type } from \"@colyseus/schema\" ; class Player extends Schema { @type ( \"number\" ) x : number ; @type ( \"number\" ) y : number ; } class MyState extends Schema { @type ({ map : Player }) players = new MapSchema < Player > (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; const MapSchema = schema . MapSchema ; class Player extends Schema { } schema . defineTypes ( Player , { x : \"number\" , y : \"number\" }); class MyState extends Schema { constructor () { super (); this . players = new MapSchema (); } } schema . defineTypes ( MyState , { players : { map : Player } }); Looping through the items of a MapSchema \u00b6 for ( let id in this . players ) { const player : Player = this . players [ id ]; console . log ( id , player ); } Experimental: Filtering out fields for specific clients \u00b6 This feature is experimental The @filter() currently only works for a limited use cases, and it's not recommended for fast-paced games as it will consume too much CPU. It's only possible to filter out schema fields, it does not work for items inside arrays and maps. Field filtering is useful when you want to hide portions of your state for a particular client, to avoid cheating in case a player decides to inspect data coming from the network and seeing the unfiltered state information. Example: In a card game, the relevant data of each card should be available only for the owner of the card, or on certain conditions (e.g. card has been discarded) See @filter() callback signature: import { Client } from \"colyseus\" ; /** * DO NOT USE ARROW FUNCTION INSIDE `@filter`, AS IT WILL FORCE A DIFFERENT `this` SCOPE */ class Card extends Schema { @type ( \"string\" ) owner : string ; // contains the sessionId of Card owner @type ( \"boolean\" ) discarded : boolean = false ; @filter ( function ( this : Card , // the instance of the class `@filter` has been defined (instance of `Card`) client : Client , // the Room's `client` instance which this data is going to be filtered to value? : Card [ 'number' ], // the value of the field to be filtered. (value of `number` field) root? : Schema // the root state Schema instance ) { return this . discarded || this . owner === client . sessionId ; }); @type ( \"uint8\" ) number : number ; } Primitive types \u00b6 These are the types you can provide for the @type() decorator, and their limitations. Tip If you know exactly the range of your number properties, you can optimize the serialization by providing the right primitive type for it. Otherwise, use \"number\" , which will adds an extra byte to identify itself during serialization. Type Description Limitation \"string\" utf8 strings maximum byte size of 4294967295 \"number\" auto-detects the int or float type to be used. (adds an extra byte on output) 0 to 18446744073709551615 \"boolean\" true or false 0 or 1 \"int8\" signed 8-bit integer -128 to 127 \"uint8\" unsigned 8-bit integer 0 to 255 \"int16\" signed 16-bit integer -32768 to 32767 \"uint16\" unsigned 16-bit integer 0 to 65535 \"int32\" signed 32-bit integer -2147483648 to 2147483647 \"uint32\" unsigned 32-bit integer 0 to 4294967295 \"int64\" signed 64-bit integer -9223372036854775808 to 9223372036854775807 \"uint64\" unsigned 64-bit integer 0 to 18446744073709551615 \"float32\" single-precision floating-point number -3.40282347e+38 to 3.40282347e+38 \"float64\" double-precision floating-point number -1.7976931348623157e+308 to 1.7976931348623157e+308 Backwards/forwards compability \u00b6 Backwards/fowards compatibility is possible by declaring new fields at the end of existing structures, and earlier declarations to not be removed, but be marked @deprecated() when needed. This is particularly useful for native-compiled targets, such as C#, C++, Haxe, etc - where the client-side can potentially not have the most up-to-date version of the schema definitions. Limitations and best practices \u00b6 NaN or null numbers are encoded as 0 null strings are encoded as \"\" Infinity numbers are encoded as Number.MAX_SAFE_INTEGER Multi-dimensional arrays are not supported. See how to use 1D arrays as multi-dimensional Items inside Arrays and Maps must be all instance of the same type. @colyseus/schema encodes only field values in the specified order. Both encoder (server) and decoder (client) must have same schema definition. The order of the fields must be the same. Avoid manipulating indexes of an array. This result in at least 2 extra bytes for each index change. Example: If you have an array of 20 items, and remove the first item (through shift() ) this means 38 extra bytes to be serialized. Avoid moving keys of maps. As of arrays, it adds 2 extra bytes per key move. Client-side \u00b6 Callbacks \u00b6 You can use the following callbacks within the schema structures in the client-side to handle changes coming from the server-side. onChange (changes) onAdd (instance, key) onRemove (instance, key) onChange (instance, key) C#, C++, Haxe When using statically typed languages, you need to generate the client-side schema files based on your TypeScript schema definitions. See generating schema on the client-side . onChange (changes: DataChange[]) \u00b6 You can register the onChange to track a single object's property changes. The onChange callback is called with an array of changed properties, along with their previous value. JavaScript room . state . onChange = ( changes ) => { changes . forEach ( change => { console . log ( change . field ); console . log ( change . value ); console . log ( change . previousValue ); }); }; LUA room . state [ 'on_change' ] = function ( changes ) for i , change in ipairs ( changes ) do print ( change . field ) print ( change . value ) print ( change . previousValue ) end end C# room . State . OnChange += ( changes ) => { changes . ForEach (( obj ) => { Debug . Log ( obj . Field ); Debug . Log ( obj . Value ); Debug . Log ( obj . PreviousValue ); }); }; You cannot register a onChange callback for objects that haven't been synchronized to the client-side yet. The onChange works differently if used directly in an ArraySchema or MapSchema onAdd (instance, key) \u00b6 The onAdd callback can only be used in maps ( MapSchema ) and arrays ( ArraySchema ). The onAdd callback is called with the added instance and its key on holder object as argument. JavaScript room . state . players . onAdd = ( player , key ) => { console . log ( player , \"has been added at\" , key ); // add your player entity to the game world! // If you want to track changes on a child object inside a map, this is a common pattern: player . onChange = function ( changes ) { changes . forEach ( change => { console . log ( change . field ); console . log ( change . value ); console . log ( change . previousValue ); }) }; // force \"onChange\" to be called immediatelly player . triggerAll (); }; LUA room . state . players [ 'on_add' ] = function ( player , key ) print ( \"player has been added at\" , key ); -- add your player entity to the game world! -- If you want to track changes on a child object inside a map, this is a common pattern: player [ 'on_change' ] = function ( changes ) for i , change in ipairs ( changes ) do print ( change . field ) print ( change . value ) print ( change . previousValue ) end end -- force \"on_change\" to be called immediatelly player . trigger_all () end C# room . State . players . OnAdd += ( Player player , string key ) => { Debug . Log ( \"player has been added at \" + key ); // add your player entity to the game world! // If you want to track changes on a child object inside a map, this is a common pattern: player . OnChange += ( changes ) => { changes . ForEach (( obj ) => { Debug . Log ( obj . Field ); Debug . Log ( obj . Value ); Debug . Log ( obj . PreviousValue ); }); }; // force \"OnChange\" to be called immediatelly e . Value . TriggerAll (); }; onRemove (instance, key) \u00b6 The onRemove callback can only be used in maps ( MapSchema ) and arrays ( ArraySchema ). The onRemove callback is called with the removed instance and its key on holder object as argument. JavaScript room . state . players . onRemove = ( player , key ) => { console . log ( player , \"has been removed at\" , key ); // remove your player entity from the game world! }; LUA room . state . players [ 'on_remove' ] = function ( player , key ) print ( \"player has been removed at \" .. key ); -- remove your player entity from the game world! end C# room . State . players . OnRemove += ( Player player , string key ) => { Debug . Log ( \"player has been removed at \" + key ); // remove your player entity from the game world! }; onChange (instance, key) \u00b6 When registering a onChange callback on a MapSchema or ArraySchema instance, you can detect whenever a object has been changed inside that container. JavaScript room . state . players . onChange = ( player , key ) => { console . log ( player , \"have changes at\" , key ); }; LUA room . state . players [ 'on_change' ] = function ( player , key ) print ( \"player have changes at \" .. key ); end C# room . State . players . OnChange += ( Player player , string key ) => { Debug . Log ( \"player have changes at \" + key ); }; It's not possible to know exactly which properties have changed using this method. See onChange (changes) if you need to access the list of changes Important The onChange callback is not triggered during onAdd or onRemove . Consider registering onAdd and onRemove if you need to detect changes during these steps too. Client-side schema generation \u00b6 This is only applicable if you're using a statically typed language such as C#, C++, or Haxe. From your server project, you can run npx schema-codegen to automatically generate the client-side schema files. npx schema-codegen --help Output: schema-codegen [path/to/Schema.ts] Usage (C#/Unity) schema-codegen src/Schema.ts --output client-side/ --csharp --namespace MyGame.Schema Valid options: --output: fhe output directory for generated client-side schema files --csharp: generate for C#/Unity --cpp: generate for C++ --haxe: generate for Haxe --ts: generate for TypeScript --js: generate for JavaScript --java: generate for Java Optional: --namespace: generate namespace on output code C# / Unity3d \u00b6 Below is a real example to generate the C# schema files from the demo Unity3d project . npx schema-codegen DemoRoom.ts --csharp --output ../Assets/ generated: Player.cs generated: State.cs","title":"Schema"},{"location":"state/schema/#state-handling-schema","text":"The SchemaSerializer has been introduced since Colyseus 0.10, and it's the default serialization method. The Schema strutures are meant to be used only for the room's state (synchronizeable data). You do not need to use Schema and its other structures for data that's part of your algorithms that aren't synchronizeable.","title":"State Handling \u00bb Schema"},{"location":"state/schema/#server-side","text":"To use the SchemaSerializer , you must: Have a state class extending the Schema class Annotate all your synchonizable properties with the @type() decorator Instantiate the state for your room ( this.setState(new MyState()) ) Are you not using TypeScript? Decorators are not part of ECMAScript yet , so the type syntax on plain JavaScript is still a bit odd to use, which you can see in the \"JavaScript\" tab for each snippet. TypeScript import { Schema , type } from \"@colyseus/schema\" ; class MyState extends Schema { @type ( \"string\" ) currentTurn : string ; } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; class MyState extends Schema { } schema . defineTypes ( MyState , { currentTurn : \"string\" });","title":"Server-side"},{"location":"state/schema/#custom-child-data-type","text":"You may define more custom data types inside your \"root\" state definition, as a direct reference, map, or array. TypeScript import { Schema , type } from \"@colyseus/schema\" ; class World extends Schema { @type ( \"number\" ) width : number ; @type ( \"number\" ) height : number ; @type ( \"number\" ) items : number = 10 ; } class MyState extends Schema { @type ( World ) world : World = new World (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; class World extends Schema { } schema . defineTypes ( World , { width : \"number\" , height : \"number\" , items : \"number\" }); class MyState extends Schema { constructor () { super (); this . world = new World (); } } schema . defineTypes ( MyState , { world : World });","title":"Custom child data type"},{"location":"state/schema/#array-of-custom-data-type","text":"When using arrays within State related schema it's important to use the ArraySchema type. Do not use plain arrays inside your State classes (those which extend Schema ). Using plain arrays inside your methods is ok for game logic or otherwise; but not for syncronised state members. ArraySchema is recommended for describing the world map, or any collection in your game. They have all the methods available in an Array , but it's synchronizable. TypeScript import { Schema , ArraySchema , type } from \"@colyseus/schema\" ; class Block extends Schema { @type ( \"number\" ) x : number ; @type ( \"number\" ) y : number ; } class MyState extends Schema { @type ([ Block ]) blocks = new ArraySchema < Block > (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; const ArraySchema = schema . ArraySchema ; class Block extends Schema { } schema . defineTypes ( Block , { x : \"number\" , y : \"number\" }); class MyState extends Schema { constructor () { super (); this . blocks = new ArraySchema (); } } schema . defineTypes ( MyState , { blocks : [ Block ], });","title":"Array of custom data type"},{"location":"state/schema/#map-of-custom-data-type","text":"When using a map, it's important to use the MapSchema type. Do not use a plain object or the native Map type. MapSchema is recommended to track your game entities by id, such as players, enemies, etc. TypeScript import { Schema , MapSchema , type } from \"@colyseus/schema\" ; class Player extends Schema { @type ( \"number\" ) x : number ; @type ( \"number\" ) y : number ; } class MyState extends Schema { @type ({ map : Player }) players = new MapSchema < Player > (); } JavaScript const schema = require ( '@colyseus/schema' ); const Schema = schema . Schema ; const MapSchema = schema . MapSchema ; class Player extends Schema { } schema . defineTypes ( Player , { x : \"number\" , y : \"number\" }); class MyState extends Schema { constructor () { super (); this . players = new MapSchema (); } } schema . defineTypes ( MyState , { players : { map : Player } });","title":"Map of custom data type"},{"location":"state/schema/#looping-through-the-items-of-a-mapschema","text":"for ( let id in this . players ) { const player : Player = this . players [ id ]; console . log ( id , player ); }","title":"Looping through the items of a MapSchema"},{"location":"state/schema/#experimental-filtering-out-fields-for-specific-clients","text":"This feature is experimental The @filter() currently only works for a limited use cases, and it's not recommended for fast-paced games as it will consume too much CPU. It's only possible to filter out schema fields, it does not work for items inside arrays and maps. Field filtering is useful when you want to hide portions of your state for a particular client, to avoid cheating in case a player decides to inspect data coming from the network and seeing the unfiltered state information. Example: In a card game, the relevant data of each card should be available only for the owner of the card, or on certain conditions (e.g. card has been discarded) See @filter() callback signature: import { Client } from \"colyseus\" ; /** * DO NOT USE ARROW FUNCTION INSIDE `@filter`, AS IT WILL FORCE A DIFFERENT `this` SCOPE */ class Card extends Schema { @type ( \"string\" ) owner : string ; // contains the sessionId of Card owner @type ( \"boolean\" ) discarded : boolean = false ; @filter ( function ( this : Card , // the instance of the class `@filter` has been defined (instance of `Card`) client : Client , // the Room's `client` instance which this data is going to be filtered to value? : Card [ 'number' ], // the value of the field to be filtered. (value of `number` field) root? : Schema // the root state Schema instance ) { return this . discarded || this . owner === client . sessionId ; }); @type ( \"uint8\" ) number : number ; }","title":"Experimental: Filtering out fields for specific clients"},{"location":"state/schema/#primitive-types","text":"These are the types you can provide for the @type() decorator, and their limitations. Tip If you know exactly the range of your number properties, you can optimize the serialization by providing the right primitive type for it. Otherwise, use \"number\" , which will adds an extra byte to identify itself during serialization. Type Description Limitation \"string\" utf8 strings maximum byte size of 4294967295 \"number\" auto-detects the int or float type to be used. (adds an extra byte on output) 0 to 18446744073709551615 \"boolean\" true or false 0 or 1 \"int8\" signed 8-bit integer -128 to 127 \"uint8\" unsigned 8-bit integer 0 to 255 \"int16\" signed 16-bit integer -32768 to 32767 \"uint16\" unsigned 16-bit integer 0 to 65535 \"int32\" signed 32-bit integer -2147483648 to 2147483647 \"uint32\" unsigned 32-bit integer 0 to 4294967295 \"int64\" signed 64-bit integer -9223372036854775808 to 9223372036854775807 \"uint64\" unsigned 64-bit integer 0 to 18446744073709551615 \"float32\" single-precision floating-point number -3.40282347e+38 to 3.40282347e+38 \"float64\" double-precision floating-point number -1.7976931348623157e+308 to 1.7976931348623157e+308","title":"Primitive types"},{"location":"state/schema/#backwardsforwards-compability","text":"Backwards/fowards compatibility is possible by declaring new fields at the end of existing structures, and earlier declarations to not be removed, but be marked @deprecated() when needed. This is particularly useful for native-compiled targets, such as C#, C++, Haxe, etc - where the client-side can potentially not have the most up-to-date version of the schema definitions.","title":"Backwards/forwards compability"},{"location":"state/schema/#limitations-and-best-practices","text":"NaN or null numbers are encoded as 0 null strings are encoded as \"\" Infinity numbers are encoded as Number.MAX_SAFE_INTEGER Multi-dimensional arrays are not supported. See how to use 1D arrays as multi-dimensional Items inside Arrays and Maps must be all instance of the same type. @colyseus/schema encodes only field values in the specified order. Both encoder (server) and decoder (client) must have same schema definition. The order of the fields must be the same. Avoid manipulating indexes of an array. This result in at least 2 extra bytes for each index change. Example: If you have an array of 20 items, and remove the first item (through shift() ) this means 38 extra bytes to be serialized. Avoid moving keys of maps. As of arrays, it adds 2 extra bytes per key move.","title":"Limitations and best practices"},{"location":"state/schema/#client-side","text":"","title":"Client-side"},{"location":"state/schema/#callbacks","text":"You can use the following callbacks within the schema structures in the client-side to handle changes coming from the server-side. onChange (changes) onAdd (instance, key) onRemove (instance, key) onChange (instance, key) C#, C++, Haxe When using statically typed languages, you need to generate the client-side schema files based on your TypeScript schema definitions. See generating schema on the client-side .","title":"Callbacks"},{"location":"state/schema/#onchange-changes-datachange","text":"You can register the onChange to track a single object's property changes. The onChange callback is called with an array of changed properties, along with their previous value. JavaScript room . state . onChange = ( changes ) => { changes . forEach ( change => { console . log ( change . field ); console . log ( change . value ); console . log ( change . previousValue ); }); }; LUA room . state [ 'on_change' ] = function ( changes ) for i , change in ipairs ( changes ) do print ( change . field ) print ( change . value ) print ( change . previousValue ) end end C# room . State . OnChange += ( changes ) => { changes . ForEach (( obj ) => { Debug . Log ( obj . Field ); Debug . Log ( obj . Value ); Debug . Log ( obj . PreviousValue ); }); }; You cannot register a onChange callback for objects that haven't been synchronized to the client-side yet. The onChange works differently if used directly in an ArraySchema or MapSchema","title":"onChange (changes: DataChange[])"},{"location":"state/schema/#onadd-instance-key","text":"The onAdd callback can only be used in maps ( MapSchema ) and arrays ( ArraySchema ). The onAdd callback is called with the added instance and its key on holder object as argument. JavaScript room . state . players . onAdd = ( player , key ) => { console . log ( player , \"has been added at\" , key ); // add your player entity to the game world! // If you want to track changes on a child object inside a map, this is a common pattern: player . onChange = function ( changes ) { changes . forEach ( change => { console . log ( change . field ); console . log ( change . value ); console . log ( change . previousValue ); }) }; // force \"onChange\" to be called immediatelly player . triggerAll (); }; LUA room . state . players [ 'on_add' ] = function ( player , key ) print ( \"player has been added at\" , key ); -- add your player entity to the game world! -- If you want to track changes on a child object inside a map, this is a common pattern: player [ 'on_change' ] = function ( changes ) for i , change in ipairs ( changes ) do print ( change . field ) print ( change . value ) print ( change . previousValue ) end end -- force \"on_change\" to be called immediatelly player . trigger_all () end C# room . State . players . OnAdd += ( Player player , string key ) => { Debug . Log ( \"player has been added at \" + key ); // add your player entity to the game world! // If you want to track changes on a child object inside a map, this is a common pattern: player . OnChange += ( changes ) => { changes . ForEach (( obj ) => { Debug . Log ( obj . Field ); Debug . Log ( obj . Value ); Debug . Log ( obj . PreviousValue ); }); }; // force \"OnChange\" to be called immediatelly e . Value . TriggerAll (); };","title":"onAdd (instance, key)"},{"location":"state/schema/#onremove-instance-key","text":"The onRemove callback can only be used in maps ( MapSchema ) and arrays ( ArraySchema ). The onRemove callback is called with the removed instance and its key on holder object as argument. JavaScript room . state . players . onRemove = ( player , key ) => { console . log ( player , \"has been removed at\" , key ); // remove your player entity from the game world! }; LUA room . state . players [ 'on_remove' ] = function ( player , key ) print ( \"player has been removed at \" .. key ); -- remove your player entity from the game world! end C# room . State . players . OnRemove += ( Player player , string key ) => { Debug . Log ( \"player has been removed at \" + key ); // remove your player entity from the game world! };","title":"onRemove (instance, key)"},{"location":"state/schema/#onchange-instance-key","text":"When registering a onChange callback on a MapSchema or ArraySchema instance, you can detect whenever a object has been changed inside that container. JavaScript room . state . players . onChange = ( player , key ) => { console . log ( player , \"have changes at\" , key ); }; LUA room . state . players [ 'on_change' ] = function ( player , key ) print ( \"player have changes at \" .. key ); end C# room . State . players . OnChange += ( Player player , string key ) => { Debug . Log ( \"player have changes at \" + key ); }; It's not possible to know exactly which properties have changed using this method. See onChange (changes) if you need to access the list of changes Important The onChange callback is not triggered during onAdd or onRemove . Consider registering onAdd and onRemove if you need to detect changes during these steps too.","title":"onChange (instance, key)"},{"location":"state/schema/#client-side-schema-generation","text":"This is only applicable if you're using a statically typed language such as C#, C++, or Haxe. From your server project, you can run npx schema-codegen to automatically generate the client-side schema files. npx schema-codegen --help Output: schema-codegen [path/to/Schema.ts] Usage (C#/Unity) schema-codegen src/Schema.ts --output client-side/ --csharp --namespace MyGame.Schema Valid options: --output: fhe output directory for generated client-side schema files --csharp: generate for C#/Unity --cpp: generate for C++ --haxe: generate for Haxe --ts: generate for TypeScript --js: generate for JavaScript --java: generate for Java Optional: --namespace: generate namespace on output code","title":"Client-side schema generation"},{"location":"state/schema/#c-unity3d","text":"Below is a real example to generate the C# schema files from the demo Unity3d project . npx schema-codegen DemoRoom.ts --csharp --output ../Assets/ generated: Player.cs generated: State.cs","title":"C# / Unity3d"},{"location":"tutorials/","text":"Nothing here yet. \ud83d\ude2d","title":"Home"}]}